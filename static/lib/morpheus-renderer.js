/*
 * Copyright 2011-2013, CircuitHub.com
 */
var morpheus = morpheus || {}; /* Redeclaring morpheus is fine: behaves like a no-op (https://developer.mozilla.org/en/JavaScript/Reference/Scope_Cheatsheet) */

morpheus.renderer = 
// Generated by CoffeeScript 1.4.0
(function() {
  "use strict";

  var createScene, exports, gl, math_degToRad, math_invsqrt2, math_radToDeg, math_sqrt2, modelArguments, modelRotate, modelShaders, runScene, safeExport, safeTry, state,
    __slice = [].slice;

  math_sqrt2 = Math.sqrt(2.0);

  math_invsqrt2 = 1.0 / math_sqrt2;

  math_degToRad = Math.PI / 180.0;

  math_radToDeg = 180.0 / Math.PI;

  Math.clamp = function(s, min, max) {
    return Math.min(Math.max(s, min), max);
  };

  morpheus.log = ((typeof console !== "undefined" && console !== null) && (console.log != null) ? function() {
    return console.log.apply(console, arguments);
  } : function() {});

  morpheus.logDebug = ((typeof morpheusDebug !== "undefined" && morpheusDebug !== null) && morpheusDebug && (typeof console !== "undefined" && console !== null) && (console.log != null) ? function() {
    return console.log.apply(console, arguments);
  } : function() {});

  morpheus.logInternalError = ((typeof console !== "undefined" && console !== null) && (console.error != null) ? function() {
    return console.error.apply(console, arguments);
  } : function() {});

  morpheus.logApiError = ((typeof console !== "undefined" && console !== null) && (console.error != null) ? function() {
    return console.error.apply(console, arguments);
  } : function() {});

  morpheus.logApiWarning = ((typeof console !== "undefined" && console !== null) && (console.warn != null) ? function() {
    return console.warn.apply(console, arguments);
  } : function() {});

  morpheus.logException = function(locationName, error) {
    var logArgs;
    logArgs = ["Uncaught exception in `" + locationName + "`:\n"];
    logArgs.push((error.message != null ? "" + error.message + "\n" : error));
    if (error.stack != null) {
      logArgs.push(error.stack);
    }
    morpheus.logInternalError.apply(morpheus, logArgs);
  };

  safeExport = function(name, errorValue, callback) {
    return safeTry(name, callback, function(error) {
      morpheus.logException(name, error);
      return errorValue;
    });
  };

  safeTry = function(name, callback, errorCallback) {
    if ((typeof morpheusDebug !== "undefined" && morpheusDebug !== null) && morpheusDebug) {
      return callback;
    } else {
      return function() {
        try {
          return callback.apply(null, arguments);
        } catch (error) {
          return errorCallback(error);
        }
      };
    }
  };

  gl = glQuery;

  state = {
    canvas: null,
    context: null,
    nextFrame: null,
    shader: {
      program: null,
      vs: null,
      fs: null
    },
    rotation: [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0],
    clearColor: [0.2, 0.2, 0.2, 1.0]
  };

  modelShaders = safeExport('morpheus.renderer.modelShaders', false, function(modelName, shaders) {
    var success;
    success = true;
    if (!(state.context != null)) {
      throw "WebGL context is not available.";
    }
    if (!(shaders != null) || shaders.length < 2 || shaders[0].length === 0 || shaders[1].length === 0) {
      return;
    }
    if (!(state.shader.program != null)) {
      state.shader.program = state.context.createProgram();
      state.shader.vs = state.context.createShader(state.context.VERTEX_SHADER);
      state.context.attachShader(state.shader.program, state.shader.vs);
      state.shader.fs = state.context.createShader(state.context.FRAGMENT_SHADER);
      state.context.attachShader(state.shader.program, state.shader.fs);
    }
    state.context.shaderSource(state.shader.vs, shaders[0]);
    state.context.shaderSource(state.shader.fs, shaders[1]);
    state.context.compileShader(state.shader.vs);
    if (!state.context.getShaderParameter(state.shader.vs, state.context.COMPILE_STATUS)) {
      morpheus.logApiError("Shader compile failed:\n" + (state.context.getShaderInfoLog(state.shader.vs)) + "\n" + shaders[0]);
    }
    state.context.compileShader(state.shader.fs);
    if (!state.context.getShaderParameter(state.shader.fs, state.context.COMPILE_STATUS)) {
      morpheus.logApiError("Shader compile failed:\n" + (state.context.getShaderInfoLog(state.shader.fs)) + "\n" + shaders[1]);
    }
    state.context.linkProgram(state.shader.program);
    if (!state.context.getProgramParameter(state.shader.program, state.context.LINK_STATUS)) {
      morpheus.logApiError("Shader link failed:\n" + (state.context.getProgramInfoLog(state.shader.progam)));
    }
    (gl('scene')).shaderProgram(state.shader.program);
    gl.refresh(state.shader.program);
    return success;
  });

  modelArguments = safeExport('morpheus.renderer.modelArguments', void 0, function(modelName, args, params) {
    var arg, i, id, nom, param, paramToUniform, uniformID, unwrap, x, _ref;
    unwrap = function(data) {
      switch (data._tag) {
        case 'tolerance':
        case 'range':
          return data[0];
        default:
          return data;
      }
    };
    paramToUniform = {};
    if (params != null) {
      for (uniformID in params) {
        param = params[uniformID];
        id = unwrap(param)[0];
        paramToUniform[id] = uniformID;
      }
    }
    for (id in args) {
      arg = args[id];
      uniformID = (_ref = paramToUniform[id]) != null ? _ref : id;
      if ((!Array.isArray(arg)) && (typeof arg === 'object') && (arg.min != null) && (arg.max != null)) {
        nom = null;
        if (Array.isArray(arg.min)) {
          nom = (function() {
            var _i, _len, _ref1, _results;
            _ref1 = arg.min;
            _results = [];
            for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
              x = _ref1[i];
              _results.push((x + arg.max[i]) * 0.5);
            }
            return _results;
          })();
        } else {
          nom = (arg.min + arg.max) * 0.5;
        }
        (gl(modelName)).uniform(uniformID, nom);
      } else {
        (gl(modelName)).uniform(uniformID, arg);
      }
    }
  });

  modelRotate = safeExport('morpheus.renderer.modelRotate', void 0, function(modelName, angles) {
    gl.matrix3.rotateZY(state.rotation, state.rotation, angles);
    (gl(modelName)).uniform('model', state.rotation);
  });

  createScene = safeExport('morpheus.renderer.createScene', void 0, function(context) {
    var indices, positions;
    state.context = context;
    positions = [1.0, 1.0, -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0];
    indices = [0, 1, 2, 0, 2, 3, 4, 7, 6, 4, 6, 5, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23];
    if ((state.vbo != null)) {
      context.deleteBuffer(state.vbo);
    }
    if ((state.ibo != null)) {
      context.deleteBuffer(state.ibo);
    }
    state.vbo = context.createBuffer();
    context.bindBuffer(context.ARRAY_BUFFER, state.vbo);
    context.bufferData(context.ARRAY_BUFFER, new Float32Array(positions), context.STATIC_DRAW);
    state.ibo = context.createBuffer();
    context.bindBuffer(context.ELEMENT_ARRAY_BUFFER, state.ibo);
    context.bufferData(context.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), context.STATIC_DRAW);
    gl.scene({
      'scene': ''
    }).vertexAttrib('position', state.vbo, 9 * 8, gl.FLOAT, 3, false, 0, 0).vertexElem(state.ibo, 6 * 6, gl.UNSIGNED_SHORT, 0).uniform('view', gl.matrix4.newLookAt([10.0, 10.0, 10.0], [0.0, 0.0, 0.0], [0.0, 0.0, 1.0])).uniform('projection', gl.matrix4.newOrtho(-math_sqrt2, math_sqrt2, -math_sqrt2, math_sqrt2, 0.1, 100.0)).uniform('model', state.rotation).triangles();
  });

  runScene = safeExport('morpheus.renderer.runScene', void 0, function(idleCallback) {
    var canvas, _gl;
    _gl = state.context;
    _gl.cullFace(_gl.BACK);
    _gl.enable(_gl.CULL_FACE);
    _gl.enable(_gl.BLEND);
    _gl.blendFuncSeparate(_gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA, _gl.ZERO, _gl.ONE);
    canvas = gl.canvas(state.context);
    canvas.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT).clearColor.apply(canvas, state.clearColor).start('scene', null, null, idleCallback);
  });

  exports = exports != null ? exports : {};

  exports.createScene = createScene;

  exports.runScene = runScene;

  exports.modelShaders = modelShaders;

  exports.modelArguments = modelArguments;

  exports.modelRotate = modelRotate;

  exports.clearColor = function(r, g, b, a) {
    return state.clearColor = __slice.call(arguments);
  };

  exports.getRenderingContext = function() {
    return state.context;
  };

  return exports;

}).call(this);
