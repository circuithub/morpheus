/*
 * Copyright 2013, CircuitHub.com
 */
var parameterize = parameterize || {}; /* Redeclaring parameterize is fine: behaves like a no-op (https://developer.mozilla.org/en/JavaScript/Reference/Scope_Cheatsheet) */
(function(){
var originalRequire = this.require || (void 0);


(function(/*! Stitch !*/) {
  if (!this.require) {
    var modules = {}, cache = {}, require = function(name, root) {
      var path = expand(root, name), module = cache[path], fn;
      if (module) {
        return module.exports;
      } else if (fn = modules[path] || modules[path = expand(path, './index')]) {
        module = {id: path, exports: {}};
        try {
          cache[path] = module;
          fn(module.exports, function(name) {
            return require(name, dirname(path));
          }, module);
          return module.exports;
        } catch (err) {
          delete cache[path];
          throw err;
        }
      } else {
        throw 'module \'' + name + '\' not found';
      }
    }, expand = function(root, name) {
      var results = [], parts, part;
      if (/^\.\.?(\/|$)/.test(name)) {
        parts = [root, name].join('/').split('/');
      } else {
        parts = name.split('/');
      }
      for (var i = 0, length = parts.length; i < length; i++) {
        part = parts[i];
        if (part == '..') {
          results.pop();
        } else if (part != '.' && part != '') {
          results.push(part);
        }
      }
      return results.join('/');
    }, dirname = function(path) {
      return path.split('/').slice(0, -1).join('/');
    };
    this.require = function(name) {
      return require(name, '');
    }
    this.require.define = function(bundle) {
      for (var key in bundle) {
        modules[key] = bundle[key];
        var ext = key.split('.').pop();
        if (ext.indexOf('/') === -1 && ext.length < key.length)
          modules[key.slice(0,-ext.length - 1)] = bundle[key];
      }
    };
  }
  return this.require.define;
}).call(this)({"get.js": function(exports, require, module) {// Generated by CoffeeScript 1.4.0
var parameterReader, readParameter, readTolerance, readToleranceWith, readUnit,
  __slice = [].slice;

readUnit = {
  real: function(els) {
    return Number(els[0].value);
  },
  integer: function(els) {
    return Math.round(readUnit.real(els));
  },
  natural: function(els) {
    return Math.max(0, Math.round(readUnit.integer(els)));
  },
  meter: function(els) {
    return readUnit.real(els);
  },
  meter2: function(els) {
    return [readUnit.meter([els[0]]), readUnit.meter([els[1]])];
  },
  meter3: function(els) {
    return [readUnit.meter([els[0]]), readUnit.meter([els[1]]), readUnit.meter([els[2]])];
  },
  degree: function(els) {
    return readUnit.real(els);
  }
};

readParameter = {
  real: readUnit.real,
  dimension1: readUnit.meter,
  dimension2: readUnit.meter2,
  dimension3: readUnit.meter3,
  vector2: readUnit.meter2,
  vector3: readUnit.meter3,
  point2: readUnit.meter2,
  point3: readUnit.meter3,
  pitch1: readUnit.meter,
  pitch2: readUnit.meter2,
  pitch3: readUnit.meter3,
  angle: readUnit.degree,
  polar: function(els) {
    return [readUnit.meter([els[0]]), readUnit.degree([els[1]])];
  },
  cylindrical: function(els) {
    return [readUnit.meter([els[0]]), readUnit.degree([els[1]]), readUnit.meter([els[2]])];
  },
  spherical: function(els) {
    return [readUnit.meter([els[0]]), readUnit.degree([els[1]]), readUnit.degree([els[2]])];
  },
  integer: readUnit.integer,
  natural: readUnit.natural,
  latice1: readUnit.natural,
  latice2: function(els) {
    return [readUnit.natural([els[0]]), readUnit.natural([els[1]])];
  },
  latice3: function(els) {
    return [readUnit.natural([els[0]]), readUnit.natural([els[1]]), readUnit.natural([els[2]])];
  },
  boolean: function(els) {
    return Boolean(els[0].checked);
  },
  option: function(els) {
    return els[0].options[els[0].selectedIndex].value;
  }
};

readToleranceWith = {
  '1': function(f) {
    return function(els) {
      return {
        min: f([els[0]]),
        max: f([els[1]])
      };
    };
  },
  '2': function(f) {
    return function(els) {
      return {
        min: [f([els[0]]), f([els[2]])],
        max: [f([els[1]]), f([els[3]])]
      };
    };
  },
  '3': function(f) {
    return function(els) {
      return {
        min: [f([els[0]]), f([els[2]]), f([els[4]])],
        max: [f([els[1]]), f([els[3]]), f([els[5]])]
      };
    };
  }
};

readTolerance = {
  real: readToleranceWith['1'](readUnit.real),
  dimension1: readToleranceWith['1'](readUnit.meter),
  dimension2: readToleranceWith['2'](readUnit.meter),
  dimension3: readToleranceWith['3'](readUnit.meter),
  vector2: readToleranceWith['2'](readUnit.meter),
  vector3: readToleranceWith['3'](readUnit.meter),
  point2: readToleranceWith['2'](readUnit.meter),
  point3: readToleranceWith['3'](readUnit.meter),
  pitch1: readToleranceWith['1'](readUnit.meter),
  pitch2: readToleranceWith['2'](readUnit.meter),
  pitch3: readToleranceWith['3'](readUnit.meter),
  angle: readToleranceWith['1'](readUnit.degree),
  polar: function(els) {
    return [(readToleranceWith['1'](readUnit.meter))(els.slice(0, 2)), (readToleranceWith['1'](readUnit.degree))(els.slice(2))];
  },
  cylindrical: function(els) {
    return [(readToleranceWith['1'](readUnit.meter))(els.slice(0, 2)), (readToleranceWith['1'](readUnit.degree))(els.slice(2, 4)), (readToleranceWith['1'](readUnit.meter))(els.slice(4))];
  },
  spherical: function(els) {
    return [(readToleranceWith['1'](readUnit.meter))(els.slice(0, 2)), (readToleranceWith['1'](readUnit.degree))(els.slice(2, 4)), (readToleranceWith['1'](readUnit.degree))(els.slice(4))];
  }
};

parameterReader = adt({
  Array: function(array) {
    return function(result, it) {
      var a, _i, _len;
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        a = array[_i];
        (parameterReader(a))(result, it);
      }
    };
  },
  parameters: function() {
    var description, params;
    description = arguments[0], params = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return this(params);
  },
  section: function() {
    var heading, params;
    heading = arguments[0], params = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return this(params);
  },
  tolerance: function() {
    var tolerances;
    tolerances = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return function(result, it) {
      var reader, t, _i, _len;
      reader = function(param) {
        return function(result, it) {
          var el;
          el = it.nextNode();
          return result[el.getAttribute('data-param-id')] = readTolerance[param._tag](el.querySelectorAll("input"));
        };
      };
      for (_i = 0, _len = tolerances.length; _i < _len; _i++) {
        t = tolerances[_i];
        (reader(t))(result, it);
      }
    };
  },
  _: function() {
    var tag;
    tag = this._tag;
    return function(result, it) {
      var el;
      el = it.nextNode();
      result[el.getAttribute('data-param-id')] = readParameter[tag](el.querySelectorAll("input,select"));
    };
  }
});

module.exports = function(formElement, parameters) {
  var it, matches, reader, result, selector;
  matches = function() {
    var args, node, _ref, _ref1;
    node = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return ((_ref = (_ref1 = node.matches) != null ? _ref1 : node.mozMatchesSelector) != null ? _ref : node.webkitMatchesSelector).apply(node, args);
  };
  selector = ".parameter";
  it = document.createNodeIterator(formElement, NodeFilter.SHOW_ELEMENT, {
    acceptNode: function(node) {
      if (matches(node, selector)) {
        return NodeFilter.FILTER_ACCEPT;
      } else {
        return NodeFilter.FILTER_SKIP;
      }
    }
  });
  reader = parameterReader(parameters);
  result = {};
  reader(result, it);
  return result;
};
}, "html.js": function(exports, require, module) {// Generated by CoffeeScript 1.4.0
var __slice = [].slice;

(function(adt, html) {
  var escapeAttrib, groupByTolerance, labeledCompositeTolerance, labeledElements, labeledInput, labeledInputs, labeledTolerance, resolveMeta, shortLabelLength, toleranceHTML, wrap, wrapComposite;
  shortLabelLength = 5;
  escapeAttrib = function(str) {
    return (String(str)).replace(/['"]/gi, "`");
  };
  groupByTolerance = function(as) {
    var a, copyA, gs, _i, _len, _ref, _ref1;
    gs = [];
    for (_i = 0, _len = as.length; _i < _len; _i++) {
      a = as[_i];
      if (a._tag === 'tolerance' && ((_ref = gs[gs.length - 1]) != null ? _ref._tag : void 0) === 'tolerance') {
        (_ref1 = gs[gs.length - 1]).push.apply(_ref1, a);
      } else {
        copyA = __slice.call(a);
        copyA._tag = a._tag;
        gs.push(copyA);
      }
    }
    return gs;
  };
  wrap = function() {
    var args, id;
    id = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return html.div.apply(html, [{
      "class": "parameter",
      'data-param-id': id
    }].concat(__slice.call(args)));
  };
  wrapComposite = function() {
    var args, classes, description, id;
    id = arguments[0], classes = arguments[1], description = arguments[2], args = 4 <= arguments.length ? __slice.call(arguments, 3) : [];
    return html.div.apply(html, [{
      "class": "parameter param-composite " + classes,
      'data-param-id': id,
      title: escapeAttrib(description)
    }].concat(__slice.call(args)));
  };
  labeledElements = function() {
    var elements, label;
    label = arguments[0], elements = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return html.label.apply(html, [{
      "class": "param-label"
    }, html.span({
      "class": "param-label-text"
    }, String(label))].concat(__slice.call(elements)));
  };
  labeledInput = function(label, value) {
    return labeledElements(label, html.input({
      "class": "param-input",
      type: 'text',
      value: String(value)
    }));
  };
  labeledInputs = function(n, labels, values, shortLabels) {
    var i, _i, _results;
    if (shortLabels == null) {
      shortLabels = false;
    }
    if (!shortLabels) {
      _results = [];
      for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
        _results.push(labeledInput(labels[i], values[i]));
      }
      return _results;
    } else {
      return [
        html.table({
          "class": "param-composite-table"
        }, html.thead({
          "class": "param-composite-thead"
        }, html.tr.apply(html, [{
          "class": "param-composite-thead-tr"
        }].concat(__slice.call((function() {
          var _j, _results1;
          _results1 = [];
          for (i = _j = 0; 0 <= n ? _j < n : _j > n; i = 0 <= n ? ++_j : --_j) {
            _results1.push(html.th({
              "class": "param-composite-th"
            }, labeledElements(labels[i])));
          }
          return _results1;
        })())))), html.tbody({
          "class": "param-composite-tbody"
        }, html.tr.apply(html, [{
          "class": "param-composite-tr"
        }].concat(__slice.call((function() {
          var _j, _results1;
          _results1 = [];
          for (i = _j = 0; 0 <= n ? _j < n : _j > n; i = 0 <= n ? ++_j : --_j) {
            _results1.push(html.td({
              "class": "param-composite-td"
            }, html.input({
              "class": "param-input",
              type: 'text',
              value: String(values[i])
            })));
          }
          return _results1;
        })())))))
      ];
    }
  };
  labeledTolerance = function(label, tolerance) {
    return [
      html.th({
        "class": "param-tolerance-th",
        scope: "row"
      }, html.label({
        "class": "param-label param-label-text"
      }, label)), html.td(html.input({
        "class": "param-input",
        type: 'text',
        value: String(tolerance.min)
      })), html.td(html.input({
        "class": "param-input",
        type: 'text',
        value: String(tolerance.max)
      }))
    ];
  };
  labeledCompositeTolerance = function(n, labels, tolerances) {
    var i, _i, _results;
    _results = [];
    for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
      _results.push(labeledTolerance(labels[i], {
        min: tolerances.min[i],
        max: tolerances.max[i]
      }));
    }
    return _results;
  };
  toleranceHTML = adt({
    real: function(id, meta, defaultTolerance) {
      var _ref;
      if (typeof meta === 'string') {
        meta = {
          label: meta
        };
      } else if (!(meta != null)) {
        meta = {
          label: id
        };
      } else if (!(meta.label != null)) {
        meta.label = id;
      }
      if ((_ref = meta.description) == null) {
        meta.description = "";
      }
      return html.tr.apply(html, [{
        "class": "parameter param-numeric param-real",
        'data-param-id': id,
        title: escapeAttrib(meta.description)
      }].concat(__slice.call(labeledTolerance(meta.label, defaultTolerance))));
    },
    dimension1: function(id, meta, defaultTolerance) {
      var _ref;
      if (typeof meta === 'string') {
        meta = {
          label: meta
        };
      } else if (!(meta != null)) {
        meta = {
          label: id
        };
      } else if (!(meta.label != null)) {
        meta.label = id;
      }
      if ((_ref = meta.description) == null) {
        meta.description = "";
      }
      return html.tr.apply(html, [{
        "class": "parameter param-numeric param-dimension1",
        'data-param-id': id,
        title: escapeAttrib(meta.description)
      }].concat(__slice.call(labeledTolerance(meta.label, defaultTolerance))));
    },
    dimension2: function(id, meta, defaultTolerance) {
      var tds, trs, _ref, _ref1;
      if (typeof meta === 'string') {
        meta = {
          label: meta
        };
      } else if (!(meta != null)) {
        meta = {};
      }
      if ((_ref = meta.description) == null) {
        meta.description = "";
      }
      if ((_ref1 = meta.components) == null) {
        meta.components = ["X", "Y"];
      }
      if (!Array.isArray(defaultTolerance.min)) {
        defaultTolerance.min = [defaultTolerance.min, defaultTolerance.min, defaultTolerance.min];
      }
      if (!Array.isArray(defaultTolerance.max)) {
        defaultTolerance.max = [defaultTolerance.max, defaultTolerance.max, defaultTolerance.max];
      }
      trs = !(meta.label != null) ? [] : [
        html.tr({}, html.th({
          "class": "param-composite-label",
          scope: "rowgroup"
        }, html.span({
          "class": "param-composite-label-text"
        }, escapeAttrib(meta.label))), html.th({
          "class": "param-tolerance-legend",
          scope: "col"
        }, "Min"), html.th({
          "class": "param-tolerance-legend",
          scope: "col"
        }, "Max"))
      ];
      trs = trs.concat((function() {
        var _i, _len, _ref2, _results;
        _ref2 = labeledCompositeTolerance(2, meta.components, defaultTolerance);
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          tds = _ref2[_i];
          _results.push(html.tr.apply(html, [{
            "class": "param-numeric"
          }].concat(__slice.call(tds))));
        }
        return _results;
      })());
      return html.tbody.apply(html, [{
        "class": "parameter param-composite param-dimension2",
        'data-param-id': id,
        title: escapeAttrib(meta.description)
      }].concat(__slice.call(trs)));
    },
    dimension3: function(id, meta, defaultTolerance) {
      var tds, trs, _ref, _ref1;
      if (typeof meta === 'string') {
        meta = {
          label: meta
        };
      } else if (!(meta != null)) {
        meta = {
          label: id
        };
      } else if (!(meta.label != null)) {
        meta.label = id;
      }
      if ((_ref = meta.description) == null) {
        meta.description = "";
      }
      if ((_ref1 = meta.components) == null) {
        meta.components = ["X", "Y", "Z"];
      }
      if (!Array.isArray(defaultTolerance.min)) {
        defaultTolerance.min = [defaultTolerance.min, defaultTolerance.min, defaultTolerance.min];
      }
      if (!Array.isArray(defaultTolerance.max)) {
        defaultTolerance.max = [defaultTolerance.max, defaultTolerance.max, defaultTolerance.max];
      }
      trs = !(meta.label != null) ? [] : [
        html.tr({}, html.th({
          "class": "param-composite-label",
          scope: "rowgroup"
        }, html.span({
          "class": "param-composite-label-text"
        }, escapeAttrib(meta.label))), html.th({
          "class": "param-tolerance-legend",
          scope: "col"
        }, "Min"), html.th({
          "class": "param-tolerance-legend",
          scope: "col"
        }, "Max"))
      ];
      trs = trs.concat((function() {
        var _i, _len, _ref2, _results;
        _ref2 = labeledCompositeTolerance(3, meta.components, defaultTolerance);
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          tds = _ref2[_i];
          _results.push(html.tr.apply(html, [{
            "class": "param-numeric"
          }].concat(__slice.call(tds))));
        }
        return _results;
      })());
      return html.tbody.apply(html, [{
        "class": "parameter param-composite param-dimension3",
        'data-param-id': id,
        title: escapeAttrib(meta.description)
      }].concat(__slice.call(trs)));
    },
    vector2: function() {
      throw "Unsupported tolerance type `" + this._tag + "` (TODO)";
    },
    vector3: function() {
      throw "Unsupported tolerance type `" + this._tag + "` (TODO)";
    },
    point2: function() {
      throw "Unsupported tolerance type `" + this._tag + "` (TODO)";
    },
    point3: function() {
      throw "Unsupported tolerance type `" + this._tag + "` (TODO)";
    },
    pitch1: function() {
      throw "Unsupported tolerance type `" + this._tag + "` (TODO)";
    },
    pitch2: function() {
      throw "Unsupported tolerance type `" + this._tag + "` (TODO)";
    },
    pitch3: function() {
      throw "Unsupported tolerance type `" + this._tag + "` (TODO)";
    },
    angle: function() {
      throw "Unsupported tolerance type `" + this._tag + "` (TODO)";
    },
    polar: function() {
      throw "Unsupported tolerance type `" + this._tag + "` (TODO)";
    },
    cylindrical: function() {
      throw "Unsupported tolerance type `" + this._tag + "` (TODO)";
    },
    spherical: function() {
      throw "Unsupported tolerance type `" + this._tag + "` (TODO)";
    },
    _: function() {
      throw "Unsupported tolerance type `" + this._tag + "`";
    }
  });
  resolveMeta = function(id, meta) {
    var _ref, _ref1;
    if (typeof meta === 'string') {
      meta = {
        label: meta
      };
    } else if (!(meta != null)) {
      meta = {
        label: id
      };
    } else {
      if ((_ref = meta.label) == null) {
        meta.label = id;
      }
    }
    if ((_ref1 = meta.description) == null) {
      meta.description = "";
    }
    return meta;
  };
  return module.exports = adt({
    parameters: function() {
      var description, params;
      description = arguments[0], params = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return html.div.apply(html, [{
        "class": "parameters"
      }].concat(__slice.call(adt.map(this, params))));
    },
    section: function() {
      var heading, params;
      heading = arguments[0], params = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return html.section.apply(html, [{
        "class": "param-section"
      }, html.h1({
        "class": "param-heading",
        title: escapeAttrib(heading)
      }, String(heading))].concat(__slice.call(adt.map(this, groupByTolerance(params)))));
    },
    real: function(id, meta, defaultValue) {
      meta = resolveMeta(id, meta);
      return wrap(id, html.div({
        "class": "param-numeric param-real",
        title: escapeAttrib(meta.description)
      }, html.label({
        "class": "param-label"
      }, html.span({
        "class": "param-label-text"
      }, String(meta.label)), html.input({
        "class": "param-input",
        type: 'text',
        value: String(defaultValue)
      }))));
    },
    dimension1: function(id, meta, defaultValue) {
      meta = resolveMeta(id, meta);
      return wrap(id, html.div({
        "class": "param-numeric param-dimension1",
        title: escapeAttrib(meta.description)
      }, html.label({
        "class": "param-label"
      }, html.span({
        "class": "param-label-text"
      }, String(meta.label)), html.input({
        "class": "param-input",
        type: 'text',
        value: String(defaultValue)
      }))));
    },
    dimension2: function(id, meta, defaultValue) {
      var shortLabels, _ref;
      meta = resolveMeta(id, meta);
      if ((_ref = meta.components) == null) {
        meta.components = ["X", "Y"];
      }
      shortLabels = Math.max(meta.components[0].length, meta.components[1].length) < shortLabelLength;
      if (!Array.isArray(defaultValue)) {
        defaultValue = [defaultValue, defaultValue];
      }
      return wrapComposite.apply(null, [id, "param-numeric param-dimension2", meta.description, html.label({
        "class": "param-composite-label"
      }, html.span({
        "class": "param-composite-label-text"
      }, String(meta.label)))].concat(__slice.call(labeledInputs(2, meta.components, defaultValue, shortLabels))));
    },
    dimension3: function(id, meta, defaultValue) {
      var shortLabels, _ref;
      meta = resolveMeta(id, meta);
      if ((_ref = meta.components) == null) {
        meta.components = ["X", "Y", "Z"];
      }
      shortLabels = Math.max(meta.components[0].length, meta.components[1].length, meta.components[2].length) < shortLabelLength;
      if (!Array.isArray(defaultValue)) {
        defaultValue = [defaultValue, defaultValue, defaultValue];
      }
      return wrapComposite.apply(null, [id, "param-numeric param-dimension3", meta.description, html.label({
        "class": "param-composite-label"
      }, html.span({
        "class": "param-composite-label-text"
      }, String(meta.label)))].concat(__slice.call(labeledInputs(3, meta.components, defaultValue, shortLabels))));
    },
    vector2: function(id, meta, defaultValue) {
      var shortLabels, _ref;
      meta = resolveMeta(id, meta);
      if ((_ref = meta.components) == null) {
        meta.components = ["X", "Y"];
      }
      shortLabels = Math.max(meta.components[0].length, meta.components[1].length) < shortLabelLength;
      if (!Array.isArray(defaultValue)) {
        defaultValue = [defaultValue, defaultValue];
      }
      return wrapComposite.apply(null, [id, "param-numeric param-vector2", meta.description, html.label({
        "class": "param-composite-label"
      }, html.span({
        "class": "param-composite-label-text"
      }, String(meta.label)))].concat(__slice.call(labeledInputs(2, meta.components, defaultValue, shortLabels))));
    },
    vector3: function(id, meta, defaultValue) {
      var shortLabels, _ref;
      meta = resolveMeta(id, meta);
      if ((_ref = meta.components) == null) {
        meta.components = ["X", "Y", "Z"];
      }
      shortLabels = Math.max(meta.components[0].length, meta.components[1].length, meta.components[2].length) < shortLabelLength;
      if (!Array.isArray(defaultValue)) {
        defaultValue = [defaultValue, defaultValue, defaultValue];
      }
      return wrapComposite.apply(null, [id, "param-numeric param-vector3", meta.description, html.label({
        "class": "param-composite-label"
      }, html.span({
        "class": "param-composite-label-text"
      }, String(meta.label)))].concat(__slice.call(labeledInputs(3, meta.components, defaultValue, shortLabels))));
    },
    point2: function(id, meta, defaultValue) {
      var shortLabels, _ref;
      meta = resolveMeta(id, meta);
      if ((_ref = meta.components) == null) {
        meta.components = ["X", "Y"];
      }
      shortLabels = Math.max(meta.components[0].length, meta.components[1].length) < shortLabelLength;
      if (!Array.isArray(defaultValue)) {
        defaultValue = [defaultValue, defaultValue];
      }
      return wrapComposite.apply(null, [id, "param-numeric param-point2", meta.description, html.label({
        "class": "param-composite-label"
      }, html.span({
        "class": "param-composite-label-text"
      }, String(meta.label)))].concat(__slice.call(labeledInputs(2, meta.components, defaultValue, shortLabels))));
    },
    point3: function(id, meta, defaultValue) {
      var shortLabels, _ref;
      meta = resolveMeta(id, meta);
      if ((_ref = meta.components) == null) {
        meta.components = ["X", "Y", "Z"];
      }
      shortLabels = Math.max(meta.components[0].length, meta.components[1].length, meta.components[2].length) < shortLabelLength;
      if (!Array.isArray(defaultValue)) {
        defaultValue = [defaultValue, defaultValue, defaultValue];
      }
      return wrapComposite.apply(null, [id, "param-numeric param-point3", meta.description, html.label({
        "class": "param-composite-label"
      }, html.span({
        "class": "param-composite-label-text"
      }, String(meta.label)))].concat(__slice.call(labeledInputs(3, meta.components, defaultValue, shortLabels))));
    },
    pitch1: function(id, meta, defaultValue) {
      meta = resolveMeta(id, meta);
      return wrap(id, html.div({
        "class": "param-numeric param-pitch1",
        title: escapeAttrib(meta.description)
      }, html.label({
        "class": "param-label"
      }, html.span({
        "class": "param-label-text"
      }, String(meta.label)), html.input({
        "class": "param-input",
        type: 'text',
        value: String(defaultValue)
      }))));
    },
    pitch2: function(id, meta, defaultValue) {
      var shortLabels, _ref;
      meta = resolveMeta(id, meta);
      if ((_ref = meta.components) == null) {
        meta.components = ["X", "Y"];
      }
      shortLabels = Math.max(meta.components[0].length, meta.components[1].length) < shortLabelLength;
      if (!Array.isArray(defaultValue)) {
        defaultValue = [defaultValue, defaultValue];
      }
      return wrapComposite.apply(null, [id, "param-numeric param-pitch2", meta.description, html.label({
        "class": "param-composite-label"
      }, html.span({
        "class": "param-composite-label-text"
      }, String(meta.label)))].concat(__slice.call(labeledInputs(2, meta.components, defaultValue, shortLabels))));
    },
    pitch3: function(id, meta, defaultValue) {
      var shortLabels, _ref;
      meta = resolveMeta(id, meta);
      if ((_ref = meta.components) == null) {
        meta.components = ["X", "Y", "Z"];
      }
      shortLabels = Math.max(meta.components[0].length, meta.components[1].length, meta.components[2].length) < shortLabelLength;
      if (!Array.isArray(defaultValue)) {
        defaultValue = [defaultValue, defaultValue, defaultValue];
      }
      return wrapComposite.apply(null, [id, "param-numeric param-pitch3", meta.description, html.label({
        "class": "param-composite-label"
      }, html.span({
        "class": "param-composite-label-text"
      }, String(meta.label)))].concat(__slice.call(labeledInputs(3, meta.components, defaultValue, shortLabels))));
    },
    angle: function(id, meta, defaultValue) {
      throw "Unsupported parameter type `" + this._tag + "` (TODO)";
    },
    polar: function(id, meta, defaultValue) {
      throw "Unsupported parameter type `" + this._tag + "` (TODO)";
    },
    cylindrical: function(id, meta, defaultValue) {
      throw "Unsupported parameter type `" + this._tag + "` (TODO)";
    },
    spherical: function(id, meta, defaultValue) {
      throw "Unsupported parameter type `" + this._tag + "` (TODO)";
    },
    integer: function(id, meta, defaultValue) {
      throw "Unsupported parameter type `" + this._tag + "` (TODO)";
    },
    natural: function(id, meta, defaultValue) {
      throw "Unsupported parameter type `" + this._tag + "` (TODO)";
    },
    latice1: function(id, meta, defaultValue) {
      meta = resolveMeta(id, meta);
      return wrap(id, html.div({
        "class": "param-numeric param-latice1",
        title: escapeAttrib(meta.description)
      }, html.label({
        "class": "param-label"
      }, html.span({
        "class": "param-label-text"
      }, String(meta.label)), html.input({
        "class": "param-input",
        type: 'text',
        value: String(defaultValue)
      }))));
    },
    latice2: function(id, meta, defaultValue) {
      var shortLabels, _ref;
      meta = resolveMeta(id, meta);
      if ((_ref = meta.components) == null) {
        meta.components = ["X", "Y"];
      }
      shortLabels = Math.max(meta.components[0].length, meta.components[1].length) < shortLabelLength;
      if (!Array.isArray(defaultValue)) {
        defaultValue = [defaultValue, defaultValue];
      }
      return wrapComposite.apply(null, [id, "param-numeric param-latice2", meta.description, html.label({
        "class": "param-composite-label"
      }, html.span({
        "class": "param-composite-label-text"
      }, String(meta.label)))].concat(__slice.call(labeledInputs(2, meta.components, defaultValue, shortLabels))));
    },
    latice3: function(id, meta, defaultValue) {
      var shortLabels, _ref;
      meta = resolveMeta(id, meta);
      if ((_ref = meta.components) == null) {
        meta.components = ["X", "Y", "Z"];
      }
      shortLabels = Math.max(meta.components[0].length, meta.components[1].length, meta.components[2].length) < shortLabelLength;
      if (!Array.isArray(defaultValue)) {
        defaultValue = [defaultValue, defaultValue, defaultValue];
      }
      return wrapComposite.apply(null, [id, "param-numeric param-latice3", meta.description, html.label({
        "class": "param-composite-label"
      }, html.span({
        "class": "param-composite-label-text"
      }, String(meta.label)))].concat(__slice.call(labeledInputs(3, meta.components, defaultValue, shortLabels))));
    },
    option: function(id, meta, options, defaultOption) {
      var k, keyValue, v, _ref;
      if (typeof meta === 'string') {
        meta = {
          label: meta
        };
      } else if (!(meta != null)) {
        meta = {
          label: id
        };
      } else if (!(meta.label != null)) {
        meta.label = id;
      }
      if ((_ref = meta.description) == null) {
        meta.description = "";
      }
      keyValue = {};
      options = (function() {
        var _i, _len, _results;
        if (Array.isArray(options)) {
          _results = [];
          for (_i = 0, _len = options.length; _i < _len; _i++) {
            k = options[_i];
            _results.push(keyValue[k] = k);
          }
          return _results;
        } else {
          return keyValue = options;
        }
      })();
      if (defaultOption == null) {
        defaultOption = (Object.keys(keyValue))[0];
      }
      return wrap(id, html.div({
        "class": "param-numeric param-real",
        title: escapeAttrib(meta.description)
      }, labeledElements(meta.label, html.select.apply(html, [{
        "class": "param-select"
      }].concat(__slice.call((function() {
        var _results;
        _results = [];
        for (k in keyValue) {
          v = keyValue[k];
          _results.push(html.option({
            value: k,
            selected: (k === defaultOption ? true : void 0)
          }, v));
        }
        return _results;
      })()))))));
    },
    boolean: function(id, meta, defaultValue) {
      var _ref;
      if (typeof meta === 'string') {
        meta = {
          label: meta
        };
      } else if (!(meta != null)) {
        meta = {
          label: id
        };
      } else if (!(meta.label != null)) {
        meta.label = id;
      }
      if ((_ref = meta.description) == null) {
        meta.description = "";
      }
      return wrap(id, html.div({
        "class": "param-boolean",
        title: escapeAttrib(meta.description)
      }, labeledElements(meta.label, html.input({
        "class": "param-checkbox",
        type: "checkbox"
      }))));
    },
    tolerance: function() {
      var i, ii, rowgroup, rowgroups, tbodies, tolerances, _i, _len;
      tolerances = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (tolerances.length === 0) {
        return;
      }
      rowgroups = adt.map(toleranceHTML, tolerances);
      tbodies = [];
      ii = NaN;
      for (i = _i = 0, _len = rowgroups.length; _i < _len; i = ++_i) {
        rowgroup = rowgroups[i];
        if (rowgroup.tagName.toLowerCase() === "tr") {
          if (ii === i - 1) {
            tbodies[tbodies.length - 1].appendChild(rowgroup);
          } else {
            tbodies.push(html.tbody({
              "class": ""
            }, html.tr({}, html.th({
              scope: "rowgroup"
            }, ""), html.th({
              "class": "param-tolerance-legend",
              scope: "col"
            }, "Min"), html.th({
              "class": "param-tolerance-legend",
              scope: "col"
            }, "Max")), rowgroup));
          }
          ii = i;
        } else {
          tbodies.push(rowgroup);
        }
      }
      return html.div({
        "class": "parameter-set"
      }, html.table.apply(html, [{
        "class": "param-tolerance-table"
      }].concat(__slice.call(tbodies))));
    },
    range: function(id, meta, defaultValue, range) {
      throw "Unsupported parameter type `" + this._tag + "` (TODO)";
    },
    _: function() {
      throw "Unsupported parameter type `" + this._tag + "`";
    }
  });
})(typeof adt !== "undefined" && adt !== null ? adt : require('adt.js'), typeof html !== "undefined" && html !== null ? html : require('adt-html.js'));
}, "parameterize-form.js": function(exports, require, module) {// Generated by CoffeeScript 1.4.0

(function(adt) {
  var form;
  form = {
    html: require("html")
  };
  form.form = adt.constructors(form.html);
  form.get = require("./get");
  form.set = require("./set");
  form.on = function(eventKey, selector, callback) {
    var $selector;
    if (!(typeof $ !== "undefined" && $ !== null)) {
      throw "JQuery could not be found. Please ensure that $ is available before using parameterize.on.";
    }
    if (eventKey !== "update") {
      throw "Unknown event key \'" + eventKey + "\'.";
    }
    $selector = $(selector);
    $selector.on('change', 'input[type="checkbox"],select', callback);
    $selector.on('keypress', 'input[type="text"]', function(e) {
      var args;
      if (e.which === 0) {
        return;
      }
      args = arguments;
      window.setTimeout((function() {
        return callback.apply(null, args);
      }), 0);
    });
    $selector.on('keyup', 'input[type="text"]', function(e) {
      if (e.which === 0) {
        return;
      }
      switch (e.which) {
        case 8:
        case 46:
          void 0;
          break;
        case 45:
          if (!e.shiftKey) {
            return;
          }
          break;
        case 86:
        case 88:
          if (!e.ctrlKey) {
            return;
          }
          break;
        default:
          return;
      }
      callback.apply(null, arguments);
    });
  };
  form.off = function(eventKey, selector) {
    var $selector;
    if (!(typeof $ !== "undefined" && $ !== null)) {
      throw "JQuery could not be found. Please ensure that $ is available before using parameterize.off.";
    }
    if (eventKey !== "update") {
      throw "Unknown event key \'" + eventKey + "\'.";
    }
    $selector = $(selector);
    $selector.off('change', 'input[type="checkbox"],select');
    $selector.off('keypress', 'input[type="text"]');
    $selector.off('keyup', 'input[type="text"]');
  };
  return module.exports = form;
})(typeof adt !== "undefined" && adt !== null ? adt : require('adt.js'));
}, "set.js": function(exports, require, module) {// Generated by CoffeeScript 1.4.0
var parameterWriter, writeParameter, writeTolerance,
  __slice = [].slice;

writeParameter = function(els, value) {
  var el, i, _i, _len;
  console.log("param", value);
  if (!Array.isArray(value)) {
    if (els.length !== 1) {
      throw "Value provided " + value + " cannot populate " + els.length + " fields.";
    }
    els[0].value = value;
  } else {
    for (i = _i = 0, _len = els.length; _i < _len; i = ++_i) {
      el = els[i];
      if (!((value != null ? value[i] : void 0) != null)) {
        throw "No value at index " + i + " in [" + value + "]";
      }
      el.value = value[i];
    }
  }
};

writeTolerance = function(els, value) {
  var el, i, j, max, min, minMax, _i, _len, _ref;
  console.log("tolerance", value);
  minMax = [value.min, value.max];
  min = minMax[0], max = minMax[1];
  if (!Array.isArray(min)) {
    if (els.length !== 2) {
      throw "Value provided {min: " + min + ", max: " + max + "} cannot populate " + els.length + " fields.";
    }
    els[0].value = min;
    els[1].value = max;
  } else {
    for (i = _i = 0, _len = els.length; _i < _len; i = ++_i) {
      el = els[i];
      j = Math.floor(i / 2);
      if (!(((_ref = minMax[i % 2]) != null ? _ref[j] : void 0) != null)) {
        throw "No value at index " + j + " in [" + minMax[i % 2] + "]";
      }
      el.value = minMax[i % 2][j];
    }
  }
};

parameterWriter = adt({
  Array: function(array) {
    return function(values, it) {
      var a, _i, _len;
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        a = array[_i];
        (parameterWriter(a))(values, it);
      }
    };
  },
  parameters: function() {
    var description, params;
    description = arguments[0], params = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return this(params);
  },
  section: function() {
    var heading, params;
    heading = arguments[0], params = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return this(params);
  },
  tolerance: function() {
    var tolerances;
    tolerances = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return function(values, it) {
      var t, writer, _i, _len;
      writer = function(param) {
        return function(values, it) {
          var el, value;
          el = it.nextNode();
          value = values[el.getAttribute('data-param-id')];
          return writeTolerance(el.querySelectorAll("input"), value);
        };
      };
      for (_i = 0, _len = tolerances.length; _i < _len; _i++) {
        t = tolerances[_i];
        (writer(t))(values, it);
      }
    };
  },
  boolean: function() {
    return function(values, it) {
      var el, els;
      el = it.nextNode();
      els = el.querySelectorAll("input");
      if (els.length > 1) {
        throw "Too many input elements for boolean argument.";
      }
      return els[0].checked = values[el.getAttribute('data-param-id')];
    };
  },
  _: function() {
    var tag;
    tag = this._tag;
    return function(values, it) {
      var el, value;
      el = it.nextNode();
      value = values[el.getAttribute('data-param-id')];
      writeParameter(el.querySelectorAll("input,select"), value);
    };
  }
});

module.exports = function(formElement, parameters, values) {
  var it, matches, selector, writer;
  matches = function() {
    var args, node, _ref, _ref1;
    node = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return ((_ref = (_ref1 = node.matches) != null ? _ref1 : node.mozMatchesSelector) != null ? _ref : node.webkitMatchesSelector).apply(node, args);
  };
  selector = ".parameter";
  it = document.createNodeIterator(formElement, NodeFilter.SHOW_ELEMENT, {
    acceptNode: function(node) {
      if (matches(node, selector)) {
        return NodeFilter.FILTER_ACCEPT;
      } else {
        return NodeFilter.FILTER_SKIP;
      }
    }
  });
  writer = parameterWriter(parameters);
  writer(values, it);
};
}});

// Assign this library to a global variable if a global variable is defined
var parameterizeExports = this.require("parameterize-form");
var k;
for (k in parameterizeExports)
  parameterize[k] = parameterizeExports[k];
// Restore the original require method
if (typeof originalRequire === 'undefined')
  delete this.require;
else
  this.require = originalRequire;
})();

