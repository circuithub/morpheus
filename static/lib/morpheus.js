/*
 * Copyright 2011-2013, CircuitHub.com
 */
var morpheus = morpheus || {}; /* Redeclaring morpheus is fine: behaves like a no-op (https://developer.mozilla.org/en/JavaScript/Reference/Scope_Cheatsheet) */

morpheus.generator = 
// Generated by CoffeeScript 1.4.0
(function() {
  "use strict";

  var asm, compileASM, compileASMBounds, compileGLSL, exports, flatten, gl, glsl, glslCompiler, glslCompilerDistance, glslLibrary, glslSceneDistance, glslSceneId, mapASM, math_degToRad, math_invsqrt2, math_radToDeg, math_sqrt2, optimizeASM, safeExport, safeTry, shallowClone, toStringPrototype, translateCSM,
    __slice = [].slice;

  flatten = function(array) {
    var a, _ref;
    return (_ref = []).concat.apply(_ref, (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        a = array[_i];
        _results.push(Array.isArray(a) ? flatten(a) : [a]);
      }
      return _results;
    })());
  };

  shallowClone = function(array) {
    return array.slice(0);
  };

  math_sqrt2 = Math.sqrt(2.0);

  math_invsqrt2 = 1.0 / math_sqrt2;

  math_degToRad = Math.PI / 180.0;

  math_radToDeg = 180.0 / Math.PI;

  Math.clamp = function(s, min, max) {
    return Math.min(Math.max(s, min), max);
  };

  morpheus.log = ((typeof console !== "undefined" && console !== null) && (console.log != null) ? function() {
    return console.log.apply(console, arguments);
  } : function() {});

  morpheus.logDebug = ((typeof morpheusDebug !== "undefined" && morpheusDebug !== null) && morpheusDebug && (typeof console !== "undefined" && console !== null) && (console.log != null) ? function() {
    return console.log.apply(console, arguments);
  } : function() {});

  morpheus.logInternalError = ((typeof console !== "undefined" && console !== null) && (console.error != null) ? function() {
    return console.error.apply(console, arguments);
  } : function() {});

  morpheus.logApiError = ((typeof console !== "undefined" && console !== null) && (console.error != null) ? function() {
    return console.error.apply(console, arguments);
  } : function() {});

  morpheus.logApiWarning = ((typeof console !== "undefined" && console !== null) && (console.warn != null) ? function() {
    return console.warn.apply(console, arguments);
  } : function() {});

  morpheus.logException = function(locationName, error) {
    var logArgs;
    logArgs = ["Uncaught exception in `" + locationName + "`:\n"];
    logArgs.push((error.message != null ? "" + error.message + "\n" : error));
    if (error.stack != null) {
      logArgs.push(error.stack);
    }
    morpheus.logInternalError.apply(morpheus, logArgs);
  };

  safeExport = function(name, errorValue, callback) {
    return safeTry(name, callback, function(error) {
      morpheus.logException(name, error);
      return errorValue;
    });
  };

  safeTry = function(name, callback, errorCallback) {
    if ((typeof morpheusDebug !== "undefined" && morpheusDebug !== null) && morpheusDebug) {
      return callback;
    } else {
      return function() {
        try {
          return callback.apply(null, arguments);
        } catch (error) {
          return errorCallback(error);
        }
      };
    }
  };

  gl = glQueryMath;

  toStringPrototype = (function() {

    function toStringPrototype(str) {
      this.str = str;
    }

    toStringPrototype.prototype.toString = function() {
      return this.str;
    };

    return toStringPrototype;

  })();

  translateCSM = safeExport('morpheus.generator.translateCSM', '', function(apiSourceCode, csmSourceCode) {
    var jsSourceCode, variablesSource;
    variablesSource = csmSourceCode.match(/var[^;]*;/g);
    csmSourceCode = (csmSourceCode.replace(/var[^;]*;/g, '')).trim();
    jsSourceCode = "\"use strict\";\n(function(){\n  /* BEGIN API */\n  \n  var exportedParameters = {};\n\n" + apiSourceCode + "\n\n  try {\n\n  /* BEGIN PARAMETERS */\n\n" + (variablesSource ? variablesSource.join('\n') : "") + "\n\n  /* BEGIN SOURCE */ //HERE\n  return scene({ params: exportedParameters }" + (csmSourceCode.trim().length > 0 ? ',' : '') + "\n\n" + csmSourceCode + "\n\n  );//*/\n  } catch(err) {\n    return String(err);\n  }\n})();";
    return jsSourceCode;
  });

  asm = {
    union: function() {
      var nodes;
      nodes = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return {
        type: 'union',
        nodes: flatten(nodes)
      };
    },
    intersect: function() {
      var flattenedNodes, n, nodes, result, _i, _len;
      nodes = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      flattenedNodes = flatten(nodes);
      result = {
        type: 'intersect',
        nodes: (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = flattenedNodes.length; _i < _len; _i++) {
            n = flattenedNodes[_i];
            if (n.type !== 'intersect') {
              _results.push(n);
            }
          }
          return _results;
        })()
      };
      for (_i = 0, _len = flattenedNodes.length; _i < _len; _i++) {
        n = flattenedNodes[_i];
        if (n.type === 'intersect') {
          result.nodes = result.nodes.concat(n.nodes);
        }
      }
      return result;
    },
    invert: function() {
      var nodes;
      nodes = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return {
        type: 'invert',
        nodes: flatten(nodes)
      };
    },
    mirror: function() {
      var attr, nodes;
      attr = arguments[0], nodes = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return {
        type: 'mirror',
        attr: attr,
        nodes: flatten(nodes)
      };
    },
    repeat: function() {
      var attr, nodes;
      attr = arguments[0], nodes = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return {
        type: 'repeat',
        attr: attr,
        nodes: flatten(nodes)
      };
    },
    translate: function() {
      var attr, nodes;
      attr = arguments[0], nodes = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return {
        type: 'translate',
        attr: attr,
        nodes: flatten(nodes)
      };
    },
    rotate: function() {
      var attr, nodes;
      attr = arguments[0], nodes = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return {
        type: 'rotate',
        attr: attr,
        nodes: flatten(nodes)
      };
    },
    scale: function() {
      var attr, nodes;
      attr = arguments[0], nodes = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return {
        type: 'scale',
        attr: attr,
        nodes: flatten(nodes)
      };
    },
    material: function() {
      var attr, nodes;
      attr = arguments[0], nodes = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return {
        type: 'material',
        attr: attr,
        nodes: flatten(nodes)
      };
    },
    halfspace: function(attr) {
      return {
        type: 'halfspace',
        attr: attr
      };
    },
    corner: function(attr) {
      return {
        type: 'corner',
        attr: attr
      };
    },
    cylinder: function(attr) {
      return {
        type: 'cylinder',
        attr: attr
      };
    },
    sphere: function(attr) {
      return {
        type: 'sphere',
        attr: attr
      };
    },
    chamfer: function() {
      var attr, nodes;
      attr = arguments[0], nodes = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return {
        type: 'chamfer',
        attr: attr,
        nodes: flatten(nodes)
      };
    },
    bevel: function() {
      var attr, nodes;
      attr = arguments[0], nodes = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return {
        type: 'bevel',
        attr: attr,
        nodes: flatten(nodes)
      };
    }
  };

  mapASM = function(preDispatch, postDispatch, stack, node, flags) {
    var n, resultNode, _i, _len, _ref;
    stack.reverse();
    resultNode = {
      type: node.type,
      attr: node.attr,
      nodes: []
    };
    if (preDispatch[node.type] != null) {
      preDispatch[node.type](stack, resultNode, flags);
    } else {
      preDispatch['default'](stack, resultNode, flags);
    }
    stack.reverse();
    stack.push(resultNode);
    _ref = node.nodes || [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      n = _ref[_i];
      mapASM(preDispatch, postDispatch, stack, n, flags);
    }
    stack.pop();
    stack.reverse();
    if (postDispatch[node.type] != null) {
      postDispatch[node.type](stack, resultNode, flags);
    } else {
      postDispatch['default'](stack, resultNode, flags);
    }
    stack.reverse();
    return stack[0];
  };

  optimizeASM = function(node, flags) {
    var postDispatch, preDispatch, resultNode;
    resultNode = {};
    if (!(flags != null)) {
      flags = {
        invert: false
      };
    }
    preDispatch = {
      invert: function(stack, node, flags) {
        return flags.invert = !flags.invert;
      },
      "default": function(stack, node, flags) {}
    };
    postDispatch = {
      invert: function(stack, node, flags) {
        flags.invert = !flags.invert;
        return stack[0].nodes.push(node);
      },
      union: function(stack, node, flags) {
        var s, _i, _len;
        for (_i = 0, _len = stack.length; _i < _len; _i++) {
          s = stack[_i];
          switch (s.type) {
            case 'union':
              stack[0].nodes = stack[0].nodes.concat(node.nodes);
              return;
          }
          break;
        }
        return stack[0].nodes.push(node);
      },
      intersect: function(stack, node, flags) {
        var s, _i, _len;
        for (_i = 0, _len = stack.length; _i < _len; _i++) {
          s = stack[_i];
          switch (s.type) {
            case 'intersect':
              stack[0].nodes = stack[0].nodes.concat(node.nodes);
              return;
          }
          break;
        }
        return stack[0].nodes.push(node);
      },
      translate: function(stack, node, flags) {
        return stack[0].nodes.push(node);
      },
      halfspace: function(stack, node, flags) {
        var n, s, _i, _j, _len, _len1, _ref;
        if (node.nodes.length > 0) {
          morpheus.logInternalError("ASM Optimize: Unexpected child nodes found in halfspace node.");
        }
        for (_i = 0, _len = stack.length; _i < _len; _i++) {
          s = stack[_i];
          switch (s.type) {
            case 'intersect':
              _ref = s.nodes;
              for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
                n = _ref[_j];
                if (n.type === 'halfspace' && n.attr.axis === node.attr.axis) {
                  if ((n.attr.val > node.attr.val && flags.invert) || (n.attr.val < node.attr.val && !flags.invert)) {
                    n.attr = node.attr;
                  }
                  return;
                }
              }
          }
          break;
        }
        return stack[0].nodes.push(node);
      },
      "default": function(stack, node, flags) {
        return stack[0].nodes.push(node);
      }
    };
    return mapASM(preDispatch, postDispatch, [
      {
        type: 'union',
        nodes: []
      }
    ], node, flags);
  };

  compileASMBounds = function(abstractSolidModel) {
    var COMPOSITION_INTERSECT, COMPOSITION_UNION, collectChildren, flags, intersectChildren, postDispatch, preDispatch, result, unionChildren;
    if (!(abstractSolidModel != null)) {
      return null;
    }
    COMPOSITION_UNION = 0;
    COMPOSITION_INTERSECT = 1;
    preDispatch = {
      invert: function(stack, node, flags) {
        return flags.invert = !flags.invert;
      },
      union: function(stack, node, flags) {
        return flags.composition.push(COMPOSITION_UNION);
      },
      intersect: function(stack, node, flags) {
        return flags.composition.push(COMPOSITION_INTERSECT);
      },
      "default": function(stack, node, flags) {}
    };
    unionChildren = function(nodes) {
      var bounds, i, n, _i, _j, _k, _len;
      bounds = [[Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]];
      for (_i = 0, _len = nodes.length; _i < _len; _i++) {
        n = nodes[_i];
        for (i = _j = 0; _j <= 2; i = ++_j) {
          bounds[0][i] = Math.min(n.bounds[0][i], bounds[0][i]);
        }
        for (i = _k = 0; _k <= 2; i = ++_k) {
          bounds[1][i] = Math.max(n.bounds[1][i], bounds[1][i]);
        }
      }
      return bounds;
    };
    intersectChildren = function(nodes) {
      var bounds, i, n, _i, _j, _k, _len;
      bounds = [[-Infinity, -Infinity, -Infinity], [Infinity, Infinity, Infinity]];
      for (_i = 0, _len = nodes.length; _i < _len; _i++) {
        n = nodes[_i];
        for (i = _j = 0; _j <= 2; i = ++_j) {
          bounds[0][i] = Math.max(n.bounds[0][i], bounds[0][i]);
        }
        for (i = _k = 0; _k <= 2; i = ++_k) {
          bounds[1][i] = Math.min(n.bounds[1][i], bounds[1][i]);
        }
      }
      return bounds;
    };
    collectChildren = function(nodes, flags) {
      var composition;
      composition = flags.composition[flags.composition.length - 1];
      if (composition === COMPOSITION_UNION) {
        return unionChildren(nodes);
      } else {
        return intersectChildren(nodes);
      }
    };
    postDispatch = {
      invert: function(stack, node, flags) {
        node.bounds = collectChildren(node.nodes, flags);
        flags.invert = !flags.invert;
        return stack[0].nodes.push(node);
      },
      union: function(stack, node, flags) {
        node.bounds = collectChildren(node.nodes, flags);
        flags.composition.pop();
        return stack[0].nodes.push(node);
      },
      intersect: function(stack, node, flags) {
        node.bounds = collectChildren(node.nodes, flags);
        flags.composition.pop();
        return stack[0].nodes.push(node);
      },
      translate: function(stack, node, flags) {
        var i, _i, _j;
        node.bounds = collectChildren(node.nodes, flags);
        for (i = _i = 0; _i <= 2; i = ++_i) {
          if (typeof node.attr.offset[i] === 'number') {
            node.bounds[0][i] += node.attr.offset[i];
          }
        }
        for (i = _j = 0; _j <= 2; i = ++_j) {
          if (typeof node.attr.offset[i] === 'number') {
            node.bounds[1][i] += node.attr.offset[i];
          }
        }
        return stack[0].nodes.push(node);
      },
      rotate: function(stack, node, flags) {
        node.bounds = collectChildren(node.nodes, flags);
        return stack[0].nodes.push(node);
      },
      scale: function(stack, node, flags) {
        node.bounds = collectChildren(node.nodes, flags);
        return stack[0].nodes.push(node);
      },
      halfspace: function(stack, node, flags) {
        node.bounds = [[-Infinity, -Infinity, -Infinity], [Infinity, Infinity, Infinity]];
        if (typeof node.attr.val === 'string') {

        } else {
          node.bounds[flags.invert ? 1 : 0][node.attr.axis] = node.attr.val;
        }
        return stack[0].nodes.push(node);
      },
      cylinder: function(stack, node, flags) {
        if (typeof node.attr.radius === 'number') {
          node.bounds = [[-node.attr.radius, -node.attr.radius, -node.attr.radius], [node.attr.radius, node.attr.radius, node.attr.radius]];
          node.bounds[0][node.attr.axis] = -Infinity;
          node.bounds[1][node.attr.axis] = Infinity;
        } else {
          node.bounds = [[-Infinity, -Infinity, -Infinity], [Infinity, Infinity, Infinity]];
        }
        return stack[0].nodes.push(node);
      },
      sphere: function(stack, node, flags) {
        if (typeof node.attr.radius === 'number') {
          node.bounds = [[-node.attr.radius, -node.attr.radius, -node.attr.radius], [node.attr.radius, node.attr.radius, node.attr.radius]];
        } else {
          node.bounds = [[-Infinity, -Infinity, -Infinity], [Infinity, Infinity, Infinity]];
        }
        return stack[0].nodes.push(node);
      },
      "default": function(stack, node, flags) {
        node.bounds = collectChildren(node.nodes, flags);
        return stack[0].nodes.push(node);
      }
    };
    flags = {
      invert: false,
      composition: [COMPOSITION_UNION]
    };
    result = mapASM(preDispatch, postDispatch, [
      {
        nodes: []
      }
    ], abstractSolidModel, flags);
    result.flags = flags;
    return result;
  };

  compileASM = safeExport('morpheus.generator.compileASM', null, function(concreteSolidModel) {
    var compileASMNode, dispatch;
    if (typeof concreteSolidModel === 'string') {
      throw concreteSolidModel;
    }
    if (!(concreteSolidModel != null)) {
      return null;
    }
    dispatch = {
      scene: function(node) {
        var n;
        if (node.nodes.length > 1) {
          return asm.union.apply(asm, (function() {
            var _i, _len, _ref, _results;
            _ref = node.nodes;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              n = _ref[_i];
              _results.push(compileASMNode(n));
            }
            return _results;
          })());
        } else if (node.nodes.length === 1) {
          return compileASMNode(node.nodes[0]);
        } else {
          return {};
        }
      },
      box: function(node) {
        /*
              if Array.isArray node.attr.dimensions
                halfspaces = for i in [0..2]
                  asm.halfspace 
                    val: glsl.mul (glsl.index node.attr.dimensions, i), 0.5
                    axis: i
                asm.mirror { axes: [0,1,2] }, asm.intersect halfspaces[0], halfspaces[1], halfspaces[2]
        */
        return asm.mirror({
          axes: [0, 1, 2]
        }, asm.corner({
          val: glsl.mul(node.attr.dimensions, 0.5)
        }));
      },
      sphere: function(node) {
        return asm.sphere({
          radius: node.attr.radius
        });
      },
      cylinder: function(node) {
        var halfspaces;
        if (node.attr.length != null) {
          halfspaces = [
            asm.halfspace({
              val: node.attr.length * 0.5,
              axis: node.attr.axis
            }), asm.invert(asm.halfspace({
              val: node.attr.length * -0.5,
              axis: node.attr.axis
            }))
          ];
          return asm.intersect(asm.cylinder({
            radius: node.attr.radius,
            axis: node.attr.axis
          }), halfspaces[0], halfspaces[1]);
        } else {
          return asm.cylinder({
            radius: node.attr.radius,
            axis: node.attr.axis
          });
        }
      },
      intersect: function(node) {
        var n;
        return asm.intersect.apply(asm, (function() {
          var _i, _len, _ref, _results;
          _ref = node.nodes;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            n = _ref[_i];
            _results.push(compileASMNode(n));
          }
          return _results;
        })());
      },
      union: function(node) {
        var n;
        return asm.union.apply(asm, (function() {
          var _i, _len, _ref, _results;
          _ref = node.nodes;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            n = _ref[_i];
            _results.push(compileASMNode(n));
          }
          return _results;
        })());
      },
      difference: function(node) {
        var n;
        if (node.nodes.length > 0) {
          return asm.intersect(compileASMNode(node.nodes[0]), asm.invert.apply(asm, (function() {
            var _i, _len, _ref, _results;
            _ref = node.nodes.slice(1, node.nodes.length);
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              n = _ref[_i];
              _results.push(compileASMNode(n));
            }
            return _results;
          })()));
        } else {
          return node;
        }
      },
      mirror: function(node) {
        var n;
        return asm.mirror.apply(asm, [node.attr].concat(__slice.call((function() {
          var _i, _len, _ref, _results;
          _ref = node.nodes;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            n = _ref[_i];
            _results.push(compileASMNode(n));
          }
          return _results;
        })())));
      },
      repeat: function(node) {
        var n;
        return asm.repeat.apply(asm, [node.attr].concat(__slice.call((function() {
          var _i, _len, _ref, _results;
          _ref = node.nodes;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            n = _ref[_i];
            _results.push(compileASMNode(n));
          }
          return _results;
        })())));
      },
      translate: function(node) {
        var n;
        return asm.translate.apply(asm, [node.attr].concat(__slice.call((function() {
          var _i, _len, _ref, _results;
          _ref = node.nodes;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            n = _ref[_i];
            _results.push(compileASMNode(n));
          }
          return _results;
        })())));
      },
      rotate: function(node) {
        var n;
        return asm.rotate.apply(asm, [node.attr].concat(__slice.call((function() {
          var _i, _len, _ref, _results;
          _ref = node.nodes;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            n = _ref[_i];
            _results.push(compileASMNode(n));
          }
          return _results;
        })())));
      },
      scale: function(node) {
        var n;
        return asm.scale.apply(asm, [node.attr].concat(__slice.call((function() {
          var _i, _len, _ref, _results;
          _ref = node.nodes;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            n = _ref[_i];
            _results.push(compileASMNode(n));
          }
          return _results;
        })())));
      },
      material: function(node) {
        var n;
        return asm.material.apply(asm, [node.attr].concat(__slice.call((function() {
          var _i, _len, _ref, _results;
          _ref = node.nodes;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            n = _ref[_i];
            _results.push(compileASMNode(n));
          }
          return _results;
        })())));
      },
      chamfer: function(node) {
        var n;
        return asm.chamfer.apply(asm, [node.attr].concat(__slice.call((function() {
          var _i, _len, _ref, _results;
          _ref = node.nodes;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            n = _ref[_i];
            _results.push(compileASMNode(n));
          }
          return _results;
        })())));
      },
      bevel: function(node) {
        var n;
        return asm.bevel.apply(asm, [node.attr].concat(__slice.call((function() {
          var _i, _len, _ref, _results;
          _ref = node.nodes;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            n = _ref[_i];
            _results.push(compileASMNode(n));
          }
          return _results;
        })())));
      },
      wedge: function(node) {
        var halfSpaceAxis, n;
        halfSpaceAxis = node.attr.axis + 1 > 2 ? 0 : node.attr.axis + 1;
        return asm.intersect.apply(asm, [asm.rotate({
          axis: node.attr.axis,
          angle: node.attr.from
        }, asm.halfspace({
          val: 0.0,
          axis: halfSpaceAxis
        })), asm.rotate({
          axis: node.attr.axis,
          angle: node.attr.to
        }, asm.invert(asm.halfspace({
          val: 0.0,
          axis: halfSpaceAxis
        })))].concat(__slice.call((function() {
          var _i, _len, _ref, _results;
          _ref = node.nodes;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            n = _ref[_i];
            _results.push(compileASMNode(n));
          }
          return _results;
        })())));
      },
      bend: function(node) {
        var direction, n, offset, offsetVec, radiusVec, upAxis;
        offset = node.attr.offset != null ? node.attr.offset : 0;
        (offsetVec = [0.0, 0.0, 0.0])[node.attr.offsetAxis] = offset;
        direction = node.attr.direction;
        if (direction == null) {
          direction = 1;
        }
        if (direction !== 1) {
          direction = -1;
        }
        if (!(node.attr.radius != null) || node.attr.radius === 0) {
          return asm.union(asm.intersect.apply(asm, __slice.call((function() {
            var _i, _len, _ref, _results;
            _ref = node.nodes;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              n = _ref[_i];
              _results.push(compileASMNode(n));
            }
            return _results;
          })()).concat([direction === 1 ? asm.translate({
            offset: offsetVec
          }, asm.rotate({
            axis: node.attr.axis,
            angle: glsl.mul(0.5, node.attr.angle)
          }, asm.halfspace({
            val: 0.0,
            axis: node.attr.offsetAxis
          }))) : asm.invert(asm.translate({
            offset: offsetVec
          }, asm.rotate({
            axis: node.attr.axis,
            angle: glsl.mul(-0.5, node.attr.angle)
          }, asm.halfspace({
            val: 0.0,
            axis: node.attr.offsetAxis
          }))))])), asm.intersect(asm.translate({
            offset: offsetVec
          }, asm.rotate.apply(asm, [{
            axis: node.attr.axis,
            angle: glsl.mul(direction, node.attr.angle)
          }].concat(__slice.call((function() {
            var _i, _len, _ref, _results;
            _ref = node.nodes;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              n = _ref[_i];
              _results.push(compileASMNode(n));
            }
            return _results;
          })())))), (direction === 1 ? asm.invert(asm.translate({
            offset: offsetVec
          }, asm.rotate({
            axis: node.attr.axis,
            angle: glsl.mul(0.5, node.attr.angle)
          }, asm.halfspace({
            val: 0.0,
            axis: node.attr.offsetAxis
          })))) : asm.translate({
            offset: offsetVec
          }, asm.rotate({
            axis: node.attr.axis,
            angle: glsl.mul(-0.5, node.attr.angle)
          }, asm.halfspace({
            val: 0.0,
            axis: node.attr.offsetAxis
          }))))));
        } else {
          upAxis = (function() {
            switch (node.attr.offsetAxis) {
              case 0:
                if (node.attr.axis === 2) {
                  return 1;
                } else {
                  return 2;
                }
              case 1:
                if (node.attr.axis === 2) {
                  return 0;
                } else {
                  return 2;
                }
              case 2:
                if (node.attr.axis === 1) {
                  return 0;
                } else {
                  return 1;
                }
            }
          })();
          (radiusVec = [0.0, 0.0, 0.0])[upAxis] = -node.attr.radius;
          return asm.union(asm.intersect.apply(asm, __slice.call((function() {
            var _i, _len, _ref, _results;
            _ref = node.nodes;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              n = _ref[_i];
              _results.push(compileASMNode(n));
            }
            return _results;
          })()).concat([direction === 1 ? asm.halfspace({
            val: offset,
            axis: node.attr.offsetAxis
          }) : asm.invert(asm.translate({
            offset: offsetVec
          }, asm.rotate({
            axis: node.attr.axis,
            angle: node.attr.angle
          }, asm.halfspace({
            val: 0.0,
            axis: node.attr.axis
          }))))])), asm.intersect(asm.translate({
            offset: glsl.sub(offsetVec, radiusVec)
          }, asm.rotate({
            axis: node.attr.axis,
            angle: node.attr.angle
          }, asm.translate.apply(asm, [{
            offset: radiusVec
          }].concat(__slice.call((function() {
            var _i, _len, _ref, _results;
            _ref = node.nodes;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              n = _ref[_i];
              _results.push(compileASMNode(n));
            }
            return _results;
          })()))))), asm.invert(asm.translate({
            offset: offsetVec
          }, asm.rotate({
            axis: node.attr.axis,
            angle: node.attr.angle
          }, asm.halfspace({
            val: 0.0,
            axis: node.attr.offsetAxis
          }))))));
        }
      }
    };
    compileASMNode = function(node) {
      switch (typeof node) {
        case 'object':
          if (dispatch[node.type] != null) {
            return dispatch[node.type](node);
          } else {
            morpheus.logInternalError("Unexpected node type '" + node.type + "'.");
            return {};
          }
          break;
        default:
          morpheus.logInternalError("Unexpected node of type '" + (typeof node) + "'.");
          return {};
      }
    };
    if (concreteSolidModel.type !== 'scene') {
      morpheus.logInternalError("Expected node of type 'scene' at the root of the solid model, instead, got '" + concreteSolidModel.type + "'.");
      return null;
    }
    return optimizeASM(compileASMNode(concreteSolidModel));
  });

  glsl = (function() {
    var api, isArrayType;
    isArrayType = function(a, typeString) {
      var element, _i, _len;
      for (_i = 0, _len = a.length; _i < _len; _i++) {
        element = a[_i];
        if (typeof element !== typeString) {
          return false;
        }
      }
      return true;
    };
    return api = {
      index: function(a, index) {
        if (Array.isArray(a)) {
          return a[index];
        } else {
          return "" + a + "[" + index + "]";
        }
      },
      floor: function(a) {
        var ai, _i, _len, _results;
        if ((Array.isArray(a)) && (isArrayType(a, 'number'))) {
          _results = [];
          for (_i = 0, _len = a.length; _i < _len; _i++) {
            ai = a[_i];
            _results.push(Math.floor(ai));
          }
          return _results;
        } else if (typeof a === 'number') {
          return Math.floor(a);
        } else {
          return "floor(" + (glsl.literal(a)) + ")";
        }
      },
      fract: function(a) {
        var ai, _i, _len, _results;
        if ((Array.isArray(a)) && (isArrayType(a, 'number'))) {
          _results = [];
          for (_i = 0, _len = a.length; _i < _len; _i++) {
            ai = a[_i];
            _results.push(ai - Math.floor(ai));
          }
          return _results;
        } else if (typeof a === 'number') {
          return a - Math.floor(a);
        } else {
          return "fract(" + (glsl.literal(a)) + ")";
        }
      },
      abs: function(a) {
        var ai, _i, _len, _results;
        if ((Array.isArray(a)) && (isArrayType(a, 'number'))) {
          _results = [];
          for (_i = 0, _len = a.length; _i < _len; _i++) {
            ai = a[_i];
            _results.push(Math.abs(ai));
          }
          return _results;
        } else if (typeof a === 'number') {
          return Math.abs(a);
        } else {
          return "abs(" + (glsl.literal(a)) + ")";
        }
      },
      cos: function(a) {
        if (typeof a === 'number') {
          return Math.cos(a);
        } else {
          return "cos(" + a + ")";
        }
      },
      sin: function(a) {
        if (typeof a === 'number') {
          return Math.sin(a);
        } else {
          return "sin(" + a + ")";
        }
      },
      dot: function(a, b) {
        var i, result, _i, _ref;
        if (typeof a === 'string' || typeof b === 'string') {
          return "dot(" + a + ", " + b + ")";
        } else if ((Array.isArray(a)) && (Array.isArray(b))) {
          if (a.length !== b.length) {
            throw "Cannot perform dot product operation with array operands of different lengths.";
          }
          if (a.length < 2 || a.length > 4) {
            throw "Cannot perform dot product operation on vectors of " + a.length + " dimensions.";
          }
          if ((isArrayType(a, 'number')) && (isArrayType(b, 'number'))) {
            result = 0.0;
            for (i = _i = 0, _ref = a.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
              result += a[i] * b[i];
            }
            return result;
          } else {
            return "dot(" + (glsl.vecLit(a)) + ", " + (glsl.vecLit(b)) + ")";
          }
        } else {
          throw "Cannot perform dot product operation on operands with types '" + (typeof a) + "' and '" + (typeof b) + "'.";
        }
      },
      cross: function(a, b) {
        if (typeof a === 'string' || typeof b === 'string') {
          return "cross(" + a + ", " + b + ")";
        } else if ((Array.isArray(a)) && (Array.isArray(b))) {
          if (a.length !== b.length) {
            throw "Cannot perform cross product operation with array operands of different lengths.";
          }
          if (a.length !== 3) {
            throw "Cannot perform cross product operation on vectors of " + a.length + " dimensions.";
          }
          if ((isArrayType(a, 'number')) && (isArrayType(b, 'number'))) {
            return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
          } else {
            return "cross(" + (glsl.vec3Lit(a)) + ", " + (glsl.vec3Lit(b)) + ")";
          }
        } else {
          throw "Cannot perform cross operation on operands with types '" + (typeof a) + "' and '" + (typeof b) + "'.";
        }
      },
      length: function(a) {
        if (isArrayType(a, 'number')) {
          return Math.sqrt(glsl.dot(a, a));
        } else {
          return "length(" + (glsl.vecLit(axis)) + ")";
        }
      },
      mul: function(a, b) {
        var i, _i, _ref, _results;
        if (typeof a === 'number' && typeof b === 'number') {
          return a * b;
        } else if (typeof a === 'number') {
          switch (a) {
            case 0:
              return 0;
            case 1:
              return b;
            case -1:
              return "-" + (glsl.literal(b));
            default:
              return "" + (glsl.floatLit(a)) + " * " + (glsl.literal(b));
          }
        } else if (typeof b === 'number') {
          switch (b) {
            case 0:
              return 0;
            case 1:
              return a;
            case -1:
              return "-" + (glsl.literal(a));
            default:
              return "" + (glsl.literal(a)) + " * " + (glsl.floatLit(b));
          }
        } else if ((Array.isArray(a)) && (Array.isArray(b))) {
          if (a.length !== b.length) {
            throw "Cannot perform multiply operation with array operands of different lengths.";
          }
          if ((isArrayType(a, 'number')) && (isArrayType(b, 'number'))) {
            _results = [];
            for (i = _i = 0, _ref = a.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
              _results.push(a[i] * b[i]);
            }
            return _results;
          } else {
            return "" + (glsl.vecLit(a)) + " * " + (glsl.vecLit(b));
          }
        } else {
          return "" + (glsl.literal(a)) + " * " + (glsl.literal(b));
        }
      },
      mod: function(a, b) {
        var i, _i, _ref, _results;
        if (typeof a === 'number' && typeof b === 'number') {
          return a % b;
        } else if ((Array.isArray(a)) && (Array.isArray(b))) {
          if (a.length !== b.length) {
            throw "Cannot perform modulo operation with array operands of different lengths.";
          }
          if ((isArrayType(a, 'number')) && (isArrayType(b, 'number'))) {
            _results = [];
            for (i = _i = 0, _ref = a.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
              _results.push(a[i] % b[i]);
            }
            return _results;
          } else {
            return "mod(" + (glsl.vecLit(a)) + "," + (glsl.vecLit(b)) + ")";
          }
        } else if (typeof a === 'number') {
          switch (a) {
            case 0:
              return 0;
            default:
              return "mod(" + (glsl.floatLit(a)) + "," + (glsl.literal(b)) + ")";
          }
        } else if (typeof b === 'number') {
          switch (b) {
            case 0:
              return NaN;
            default:
              return "mod(" + (glsl.literal(a)) + "," + (glsl.floatLit(b)) + ")";
          }
        } else {
          return "mod(" + (glsl.literal(a)) + "," + (glsl.literal(b)) + ")";
        }
      },
      div: function(a, b) {
        var i, _i, _ref, _results;
        if (typeof a === 'number' && typeof b === 'number') {
          return a / b;
        } else if (typeof a === 'number') {
          switch (a) {
            case 0:
              return 0;
            default:
              return "" + (glsl.floatLit(a)) + " / " + (glsl.literal(b));
          }
        } else if (typeof b === 'number') {
          switch (b) {
            case 0:
              return "" + (glsl.literal(a)) + " / 0.0";
            default:
              return "" + (glsl.literal(a)) + " / " + (glsl.floatLit(b));
          }
        } else if ((Array.isArray(a)) && (Array.isArray(b))) {
          if (a.length !== b.length) {
            throw "Cannot perform divide operation with array operands of different lengths.";
          }
          if ((isArrayType(a, 'number')) && (isArrayType(b, 'number'))) {
            _results = [];
            for (i = _i = 0, _ref = a.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
              _results.push(a[i] / b[i]);
            }
            return _results;
          } else {
            return "" + (glsl.vecLit(a)) + " / " + (glsl.vecLit(b));
          }
        } else {
          return "" + (glsl.literal(a)) + " / " + (glsl.literal(b));
        }
      },
      add: function(a, b) {
        var i, _i, _ref, _results;
        if (typeof a === 'number' && typeof b === 'number') {
          return a + b;
        } else if (typeof a === 'number') {
          switch (a) {
            case 0:
              return b;
            default:
              return "" + (glsl.floatLit(a)) + " + " + (glsl.literal(b));
          }
        } else if (typeof b === 'number') {
          return glsl.add(b, a);
        } else if ((Array.isArray(a)) && (Array.isArray(b))) {
          if (a.length !== b.length) {
            throw "Cannot perform add operation with array operands of different lengths.";
          }
          if ((isArrayType(a, 'number')) && (isArrayType(b, 'number'))) {
            _results = [];
            for (i = _i = 0, _ref = a.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
              _results.push(a[i] + b[i]);
            }
            return _results;
          } else {
            return "" + (glsl.vecLit(a)) + " + " + (glsl.vecLit(b));
          }
        } else {
          return "" + (glsl.literal(a)) + " + " + (glsl.literal(b));
        }
      },
      sub: function(a, b) {
        var i, _i, _ref, _results;
        if (typeof a === 'number' && typeof b === 'number') {
          return a - b;
        } else if (typeof a === 'number') {
          switch (a) {
            case 0:
              return glsl.neg(b);
            default:
              return "" + (glsl.floatLit(a)) + " - " + (glsl.literal(b));
          }
        } else if (typeof b === 'number') {
          switch (b) {
            case 0:
              return a;
            default:
              return "" + (glsl.literal(a)) + " - " + (glsl.floatLit(b));
          }
        } else if ((Array.isArray(a)) && (Array.isArray(b))) {
          if (a.length !== b.length) {
            throw "Cannot perform subtract operation with array operands of different lengths.";
          }
          if ((isArrayType(a, 'number')) && (isArrayType(b, 'number'))) {
            _results = [];
            for (i = _i = 0, _ref = a.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
              _results.push(a[i] - b[i]);
            }
            return _results;
          } else {
            return "" + (glsl.vecLit(a)) + " - " + (glsl.vecLit(b));
          }
        } else {
          return "" + (glsl.literal(a)) + " - " + (glsl.literal(b));
        }
      },
      neg: function(a) {
        var ai, _i, _len, _results;
        if (typeof a === 'number') {
          return -a;
        } else if ((Array.isArray(a)) && (isArrayType(a, 'number'))) {
          _results = [];
          for (_i = 0, _len = a.length; _i < _len; _i++) {
            ai = a[_i];
            _results.push(-ai);
          }
          return _results;
        } else {
          return "-" + (glsl.literal(a));
        }
      },
      min: function(a, b) {
        var i, _i, _ref, _ref1, _ref2, _results;
        if ((typeof a === (_ref = typeof b) && _ref === 'number')) {
          return Math.min(a, b);
        } else if ((typeof a === (_ref1 = typeof b) && _ref1 === 'string')) {
          return "min(" + a + ", " + b + ")";
        } else if (typeof a === 'string') {
          return "min(" + a + ", " + (glsl.literal(b)) + ")";
        } else if (typeof b === 'string') {
          return "min(" + (glsl.literal(a)) + ", " + b + ")";
        } else if ((Array.isArray(a)) && (Array.isArray(b))) {
          if (a.length !== b.length) {
            throw "Cannot perform min operation with array operands of different lengths.";
          }
          if ((isArrayType(a, 'number')) && (isArrayType(b, 'number'))) {
            _results = [];
            for (i = _i = 0, _ref2 = a.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
              _results.push(Math.min(a[i], b[i]));
            }
            return _results;
          } else {
            return "min(" + (glsl.vec3Lit(a)) + ", " + (glsl.vec3Lit(b)) + ")";
          }
        } else {
          throw "Operands passed to the min operation have incorrect types.";
        }
      },
      max: function(a, b) {
        var i, _i, _ref, _ref1, _ref2, _results;
        if ((typeof a === (_ref = typeof b) && _ref === 'number')) {
          return Math.max(a, b);
        } else if ((typeof a === (_ref1 = typeof b) && _ref1 === 'string')) {
          return "max(" + a + ", " + b + ")";
        } else if (typeof a === 'string') {
          return "max(" + a + ", " + (glsl.literal(b)) + ")";
        } else if (typeof b === 'string') {
          return "max(" + (glsl.literal(a)) + ", " + b + ")";
        } else if ((Array.isArray(a)) && (Array.isArray(b))) {
          if (a.length !== b.length) {
            throw "Cannot perform operation with arrays of different lengths.";
          }
          if ((isArrayType(a, 'number')) && (isArrayType(b, 'number'))) {
            _results = [];
            for (i = _i = 0, _ref2 = a.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
              _results.push(Math.max(a[i], b[i]));
            }
            return _results;
          } else {
            return "max(" + (glsl.vec3Lit(a)) + ", " + (glsl.vec3Lit(b)) + ")";
          }
        } else {
          throw "Operands passed to the max operation have incorrect types.";
        }
      },
      clamp: function(a, min, max) {
        var i, _i, _ref, _ref1, _ref2, _ref3, _ref4, _results;
        if (((typeof a === (_ref1 = typeof min) && _ref1 === (_ref = typeof max)) && _ref === 'number')) {
          return Math.clamp(a, min, max);
        } else if (((typeof a === (_ref3 = typeof min) && _ref3 === (_ref2 = typeof max)) && _ref2 === 'string')) {
          return "clamp(" + a + ", " + min + ", " + max + ")";
        } else if ((Array.isArray(a)) && (Array.isArray(min)) && (Array.isArray(max))) {
          if (a.length !== b.length) {
            throw "Cannot perform clamp operation with array operands of different lengths.";
          }
          if ((isArrayType(a, 'number')) && (isArrayType(min, 'number')) && (isArrayType(max, 'number'))) {
            _results = [];
            for (i = _i = 0, _ref4 = a.length; 0 <= _ref4 ? _i < _ref4 : _i > _ref4; i = 0 <= _ref4 ? ++_i : --_i) {
              _results.push(Math.clamp(a[i], min[i], max[i]));
            }
            return _results;
          } else {
            return "clamp(" + (glsl.vec3Lit(a)) + ", " + (glsl.vec3Lit(min)) + ", " + (glsl.vec3Lit(max)) + ")";
          }
        } else {
          return "clamp(" + (typeof a === 'string' ? a : glsl.literal(a)) + ", " + (typeof min === 'string' ? min : glsl.literal(min)) + ", " + (typeof max === 'string' ? max : glsl.literal(max)) + ")";
        }
      },
      mini: function(a, b) {
        var i, _i, _ref, _ref1, _ref2, _results;
        if ((typeof a === (_ref = typeof b) && _ref === 'number')) {
          return Math.min(a, b);
        } else if ((typeof a === (_ref1 = typeof b) && _ref1 === 'string')) {
          return "min(" + a + ", " + b + ")";
        } else if (typeof a === 'string' || typeof b === 'string') {
          return "max(" + a + ", " + b + ")";
        } else if ((Array.isArray(a)) && (Array.isArray(b))) {
          if (a.length !== b.length) {
            throw "Cannot perform operation with arrays of different lengths.";
          }
          if ((isArrayType(a, 'number')) && (isArrayType(b, 'number'))) {
            _results = [];
            for (i = _i = 0, _ref2 = a.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
              _results.push(Math.max(a[i], b[i]));
            }
            return _results;
          } else {
            return "max(vec3(" + a + "), vec3(" + b + "))";
          }
        } else {
          throw "Operands passed to the max operation have incorrect types.";
        }
      },
      maxi: function(a, b) {
        var i, _i, _ref, _ref1, _ref2, _results;
        if ((typeof a === (_ref = typeof b) && _ref === 'number')) {
          return Math.max(a, b);
        } else if ((typeof a === (_ref1 = typeof b) && _ref1 === 'string')) {
          return "max(" + a + ", " + b + ")";
        } else if (typeof a === 'string' || typeof b === 'string') {
          return "max(" + a + ", " + b + ")";
        } else if ((Array.isArray(a)) && (Array.isArray(b))) {
          if (a.length !== b.length) {
            throw "Cannot perform operation with arrays of different lengths.";
          }
          if ((isArrayType(a, 'number')) && (isArrayType(b, 'number'))) {
            _results = [];
            for (i = _i = 0, _ref2 = a.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
              _results.push(Math.max(a[i], b[i]));
            }
            return _results;
          } else {
            return "max(vec3(" + a + "), vec3(" + b + "))";
          }
        } else {
          throw "Operands passed to the max operation have incorrect types.";
        }
      },
      literal: function(a) {
        if (typeof a === 'number') {
          return glsl.floatLit(a);
        } else if (Array.isArray(a)) {
          return glsl.vecLit(a);
        } else {
          return "(" + a + ")";
        }
      },
      floatLit: function(a) {
        if (typeof a === 'number' && (a | 0) === a) {
          return a + '.0';
        } else {
          return "(" + a + ")";
        }
      },
      vecLit: function(a) {
        if (a.length > 1 && a.length < 5) {
          return glsl["vec" + a.length + "Lit"](a);
        } else {
          throw "Cannot create vector literal with length " + a.length + ".";
        }
      },
      vec2Lit: function(a) {
        if (typeof a === 'number') {
          return "vec2(" + (glsl.floatLit(a)) + ")";
        } else if (Array.isArray(a)) {
          return "vec2(" + (glsl.floatLit(a[0])) + "," + (glsl.floatLit(a[1])) + ")";
        } else {
          return "(" + a + ")";
        }
      },
      vec3Lit: function(a) {
        if (typeof a === 'number') {
          return "vec3(" + (glsl.floatLit(a)) + ")";
        } else if (Array.isArray(a)) {
          return "vec3(" + (glsl.floatLit(a[0])) + "," + (glsl.floatLit(a[1])) + "," + (glsl.floatLit(a[2])) + ")";
        } else {
          return "(" + a + ")";
        }
      },
      vec4Lit: function(a) {
        if (typeof a === 'number') {
          return "vec4(" + (glsl.floatLit(a)) + ")";
        } else if (Array.isArray(a)) {
          return "vec4(" + (glsl.floatLit(a[0])) + "," + (glsl.floatLit(a[1])) + "," + (glsl.floatLit(a[2])) + "," + (glsl.floatLit(a[3])) + ")";
        } else {
          return "(" + a + ")";
        }
      },
      axisRotation: function(axis, angle) {
        if ((isArrayType(axis, 'number')) && (typeof angle === 'number')) {
          return gl.matrix3.newAxisRotation(axis, angle);
        }
        return morpheus.logInternalError("axisRotation is not yet implemented in the GLSL API.");
        /*
              # TODO: This can (should) probably be optimized a lot...
              # Convert rotation to quaternion representation
              length = glsl.length axis
              halfAngle = glsl.mul angle, 0.5
              sinHalfOverLength = glsl.div (glsl.sin halfAngle), length
              xyz = glsl.mul axis, sinHalfOverLength
              x = glsl.index xyz, 0
              y = glsl.index xyz, 1
              z = glsl.index xyz, 2
              w = glsl.cos halfAngle
              # Convert quaternion to matrix representation       
              xx = glsl.mul x, x
              xy = glsl.mul x, y
              xz = glsl.mul x, z
              xw = glsl.mul x, w
              yy = glsl.mul y, y
              yz = glsl.mul y, z
              yw = glsl.mul y, w
              zz = glsl.mul z, z
              zw = glsl.mul z, w
              return [
                (glsl.sub 1, (glsl.mul 2, (glsl.add yy, zz))), (glsl.mul 2, (glsl.add xy, zw)),               (glsl.mul 2, (glsl.sub xz, yw)),
                (glsl.mul 2, (glsl.sub xy, zw)),               (glsl.sub 1, (glsl.mul 2, (glsl.add xx, zz))), (glsl.mul 2, (glsl.add yz, xw)),
                (glsl.mul 2, (glsl.add xz, yw)),               (glsl.mul 2, (glsl.sub yz, xw)),               (glsl.sub 1, (glsl.mul 2, (glsl.mul xx, yy)))
              ]
        */

      }
    };
  })();

  glslLibrary = {
    distanceFunctions: {
      boxChamferDist: {
        id: '_boxChamferDist',
        returnType: 'float',
        "arguments": ['vec3', 'vec3', 'vec3', 'float'],
        code: (function() {
          var center, chamferCenter, chamferDist, chamferDistLength, chamferRadius, dist, gtChamferCenter, position, radius, rel;
          position = 'a';
          center = 'b';
          radius = 'c';
          chamferRadius = 'd';
          rel = 'r';
          dist = 's';
          chamferCenter = 'cc';
          chamferDist = 'ccd';
          chamferDistLength = 'ccdl';
          gtChamferCenter = 'gtcc';
          return ["vec3 " + rel + " = abs(" + position + " - " + center + ");", "vec3 " + dist + " = max(vec3(0.0), " + rel + " - " + center + ");", "if (any(greaterThan(" + rel + ", " + center + " + vec3(" + chamferRadius + ")))) { return max(max(" + dist + ".x, " + dist + ".y), " + dist + ".z); }", "vec3 " + chamferCenter + " = " + radius + " - vec3(" + chamferRadius + ");", "bvec3 " + gtChamferCenter + " = greaterThan(" + rel + ", " + chamferCenter + ");", "if (!any(" + gtChamferCenter + ")) { return 0.0; }", "vec3 " + chamferDist + " = " + rel + " - " + chamferCenter + ";", "if (min(" + chamferDist + ".x, " + chamferDist + ".y) < 0.0 && min(" + chamferDist + ".x, " + chamferDist + ".z) < 0.0 && min(" + chamferDist + ".y, " + chamferDist + ".z) < 0.0)", "{ return max(max(" + dist + ".x, " + dist + ".y), " + dist + ".z); }", "float " + chamferDistLength + ";", "if (all(" + gtChamferCenter + ")) {", "  " + chamferDistLength + " = length(" + chamferDist + ");", "}", "else if(" + chamferDist + ".x < 0.0) {", "  " + chamferDistLength + " = length(" + chamferDist + ".yz);", "}", "else if (" + chamferDist + ".y < 0.0) {", "  " + chamferDistLength + " = length(" + chamferDist + ".xz);", "}", "else { // " + chamferDist + ".z < 0.0", "  " + chamferDistLength + " = length(" + chamferDist + ".xy);", "}", "return min(" + chamferDistLength + " - " + chamferRadius + ", 0.0);"];
        })()
      }
    },
    compile: function(libraryFunctions) {
      var argCharCode, argName, c, charCodeA, code, distanceFunction, f, i, v, _i, _j, _len, _ref, _ref1;
      code = "";
      for (f in libraryFunctions) {
        v = libraryFunctions[f];
        distanceFunction = this.distanceFunctions[f + 'Dist'];
        if (!distanceFunction) {
          morpheus.log("GLSL distance function '" + f + "Dist' could not be found.");
          continue;
        }
        code += '\n';
        code += "" + distanceFunction.returnType + " " + distanceFunction.id + "(";
        charCodeA = 'a'.charCodeAt(0);
        for (i = _i = 0, _ref = distanceFunction["arguments"].length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          argCharCode = charCodeA + i;
          argName = String.fromCharCode(argCharCode);
          code += "in " + distanceFunction["arguments"][i] + " " + argName;
          if (i < distanceFunction["arguments"].length - 1) {
            code += ',';
          }
        }
        code += ") {\n";
        _ref1 = distanceFunction.code;
        for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
          c = _ref1[_j];
          code += c + '\n';
        }
        code += "}\n";
      }
      return code;
    }
  };

  glslCompiler = function(abstractSolidModel, preDispatch, postDispatch) {
    var flags, rayOrigin, result;
    if (!(abstractSolidModel != null)) {
      return;
    }
    rayOrigin = 'ro';
    flags = {
      invert: false,
      glslFunctions: {},
      glslPrelude: [['ro', "" + rayOrigin]],
      materials: [],
      materialIdStack: [-1],
      composition: [glslCompiler.COMPOSITION_UNION]
    };
    flags.glslPrelude.code = "";
    flags.glslPrelude.counter = 0;
    result = mapASM(preDispatch, postDispatch, [
      {
        nodes: []
      }
    ], abstractSolidModel, flags);
    result.flags = flags;
    return result;
  };

  glslCompiler.COMPOSITION_UNION = 0;

  glslCompiler.COMPOSITION_INTERSECT = 1;

  glslCompiler.preludePush = function(prelude, value, valueType) {
    var name;
    name = 'r' + prelude.counter;
    prelude.counter += 1;
    prelude.code += "  " + (valueType != null ? valueType : 'vec3') + " " + name + " = " + value + ";\n";
    prelude.push([name, value]);
    return name;
  };

  glslCompiler.preludePop = function(prelude) {
    return prelude.pop()[0];
  };

  glslCompiler.preludeTop = function(prelude) {
    if (!Array.isArray(prelude || prelude.length === 0)) {
      throw "Could not retrieve top value from prelude.";
    }
    return prelude[prelude.length - 1][0];
  };

  glslCompiler.preludeAdd = function(prelude, value, valueType) {
    var name;
    name = 'r' + prelude.counter;
    prelude.counter += 1;
    prelude.code += "  " + (valueType != null ? valueType : 'vec3') + " " + name + " = " + value + ";\n";
    return name;
  };

  glslCompilerDistance = function(primitiveCallback, minCallback, maxCallback, modifyCallback) {
    var compileCompositeNode, postDispatch, preDispatch, rayOrigin;
    rayOrigin = 'ro';
    preDispatch = {
      invert: function(stack, node, flags) {
        flags.invert = !flags.invert;
      },
      union: function(stack, node, flags) {
        var i;
        flags.composition.push(glslCompiler.COMPOSITION_UNION);
        node.halfSpaces = (function() {
          var _i, _results;
          _results = [];
          for (i = _i = 0; _i <= 5; i = ++_i) {
            _results.push(null);
          }
          return _results;
        })();
      },
      intersect: function(stack, node, flags) {
        var i;
        flags.composition.push(glslCompiler.COMPOSITION_INTERSECT);
        node.halfSpaces = (function() {
          var _i, _results;
          _results = [];
          for (i = _i = 0; _i <= 5; i = ++_i) {
            _results.push(null);
          }
          return _results;
        })();
      },
      chamfer: function(stack, node, flags) {},
      bevel: function(stack, node, flags) {},
      translate: function(stack, node, flags) {
        var ro;
        ro = glslCompiler.preludeTop(flags.glslPrelude);
        glslCompiler.preludePush(flags.glslPrelude, "" + ro + " - vec3(" + node.attr.offset + ")");
      },
      rotate: function(stack, node, flags) {
        var components, cosAngle, mat, ro, sinAngle;
        ro = glslCompiler.preludeTop(flags.glslPrelude);
        if (Array.isArray(node.attr.axis)) {
          mat = glsl.axisRotation(node.attr.axis, glsl.mul(glsl.neg(math_degToRad), node.attr.angle));
          glslCompiler.preludePush(flags.glslPrelude, "mat3(" + mat + ") * " + ro);
        } else {
          cosAngle = glsl.cos(glsl.mul(-math_degToRad, node.attr.angle));
          sinAngle = glsl.sin(glsl.mul(-math_degToRad, node.attr.angle));
          components = [
            (function() {
              switch (node.attr.axis) {
                case 0:
                  return "" + ro + ".x";
                case 1:
                  return "" + (glsl.add(glsl.mul(cosAngle, ro + '.x'), glsl.mul(sinAngle, ro + '.z')));
                default:
                  return "" + (glsl.add(glsl.mul(cosAngle, ro + '.x'), glsl.mul(glsl.neg(sinAngle), ro + '.y')));
              }
            })(), (function() {
              switch (node.attr.axis) {
                case 0:
                  return "" + (glsl.add(glsl.mul(cosAngle, ro + '.y'), glsl.mul(glsl.neg(sinAngle), ro + '.z')));
                case 1:
                  return "" + ro + ".y";
                default:
                  return "" + (glsl.add(glsl.mul(sinAngle, ro + '.x'), glsl.mul(cosAngle, ro + '.y')));
              }
            })(), (function() {
              switch (node.attr.axis) {
                case 0:
                  return "" + (glsl.add(glsl.mul(sinAngle, ro + '.y'), glsl.mul(cosAngle, ro + '.z')));
                case 1:
                  return "" + (glsl.add(glsl.mul(glsl.neg(sinAngle), ro + '.x'), glsl.mul(cosAngle, ro + '.z')));
                default:
                  return "" + ro + ".z";
              }
            })()
          ];
          glslCompiler.preludePush(flags.glslPrelude, "vec3(" + components + ")");
        }
      },
      scale: function(stack, node, flags) {
        var i, ro;
        node.halfSpaces = (function() {
          var _i, _results;
          _results = [];
          for (i = _i = 0; _i <= 5; i = ++_i) {
            _results.push(null);
          }
          return _results;
        })();
        ro = glslCompiler.preludeTop(flags.glslPrelude);
        if (Array.isArray(node.attr.factor)) {
          morpheus.logInternalError("GLSL Compiler: Scale along multiple axes are not yet supported.");
        } else {
          glslCompiler.preludePush(flags.glslPrelude, glsl.div(ro, node.attr.factor));
        }
      },
      mirror: function(stack, node, flags) {
        var a, axes, axesCodes, i, ro, _i, _len, _ref;
        ro = glslCompiler.preludeTop(flags.glslPrelude);
        axes = [false, false, false];
        _ref = node.attr.axes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          a = _ref[_i];
          axes[a] = true;
        }
        if (axes[0] && axes[1] && axes[2]) {
          glslCompiler.preludePush(flags.glslPrelude, "abs(" + ro + ")");
        } else {
          axesCodes = (function() {
            var _j, _results;
            _results = [];
            for (i = _j = 0; _j <= 2; i = ++_j) {
              _results.push(axes[i] ? "abs(" + ro + "[" + i + "])" : "" + ro + "[" + i + "]");
            }
            return _results;
          })();
          glslCompiler.preludePush(flags.glslPrelude, "vec3(" + axesCodes + ")");
        }
      },
      repeat: function(stack, node, flags) {
        var cell, cellClamp, cellClampInterval, cellFloor, cellMax, cellMin, halfCells, halfInterval, halfParity, interval, parity, preludeVar, ro, roSubParity;
        ro = glslCompiler.preludeTop(flags.glslPrelude);
        if (!(node.attr.count != null)) {
          interval = glslCompiler.preludeAdd(flags.glslPrelude, glsl.vec3Lit(node.attr.interval), 'vec3');
          halfInterval = glslCompiler.preludeAdd(flags.glslPrelude, glsl.mul(0.5, interval), 'vec3');
          glslCompiler.preludePush(flags.glslPrelude, "mod(abs(" + ro + " + " + halfInterval + "), " + interval + ")}");
        } else {
          preludeVar = function(a, type) {
            return glslCompiler.preludeAdd(flags.glslPrelude, a, type);
          };
          interval = preludeVar(glsl.vec3Lit(node.attr.interval), 'vec3');
          halfInterval = preludeVar(glsl.mul(0.5, interval), 'vec3');
          parity = preludeVar(glsl.mod(node.attr.count, "vec3(2.0)"));
          halfParity = preludeVar(glsl.mul(0.5, parity));
          roSubParity = glsl.sub(ro, glsl.mul(halfParity, interval));
          cell = preludeVar(glsl.div(roSubParity, interval));
          cellFloor = preludeVar(glsl.floor(cell));
          halfCells = glsl.mul(node.attr.count, 0.5);
          cellMin = preludeVar(glsl.sub(glsl.neg(halfCells), halfParity));
          cellMax = preludeVar(glsl.sub(glsl.sub(halfCells, halfParity), "vec3(1.0)"));
          cellClamp = glsl.clamp(cellFloor, cellMin, cellMax);
          cellClampInterval = glsl.mul(cellClamp, interval);
          glslCompiler.preludePush(flags.glslPrelude, glsl.sub(glsl.sub(roSubParity, cellClampInterval), halfInterval));
        }
      },
      material: function(stack, node, flags) {
        flags.materialIdStack.push(flags.materials.length);
        flags.materials.push("vec3(" + node.attr.color + ")");
      },
      "default": function(stack, node, flags) {}
    };
    /*
    
      # TODO: This is overly complex and broken... need a better optimization method for corners....
      # (Perhaps one that lets the GLSL compiler precompute operations between uniforms (e.g. glsl.min(param0, param1)
    
      compileCorner = (ro, flags, state, chamferRadius, bevelRadius) ->
        remainingHalfSpaces = 0
        remainingHalfSpaces += 1 for h in state.hs when h != null
    
        #if remainingHalfSpaces == 1
        #  # Find the axis (from 0 to 5) for the halfSpace node
        #  for index in [0..5] when state.hs[index] != null
        #    state.codes.push primitiveCallback (if index > 2 then "#{ro}[#{index - 3}] - #{state.hs[index]}" else "-#{ro}[#{index}] + #{state.hs[index]}"), flags
        #    state.hs[index] = null
        #    break
        #  remainingHalfSpaces -= 1
        #else if remainingHalfSpaces > 1
        if remainingHalfSpaces > 0
          cornerSpaces = 0
          cornerSpaces += 1 if state.hs[0] != null or state.hs[3] != null
          cornerSpaces += 1 if state.hs[1] != null or state.hs[4] != null
          cornerSpaces += 1 if state.hs[2] != null or state.hs[5] != null
          chamferRadius = 0 if cornerSpaces == 1 or bevelRadius != 0
          cornerSize = [
            if state.hs[0] != null then (glsl.sub state.hs[0], radius) else if state.hs[3] != null then (glsl.sub radius, state.hs[3]) else 0, #TODO: zero for cornersize might be the wrong choice... (possibly something large instead?)
            if state.hs[1] != null then (glsl.sub state.hs[1], radius) else if state.hs[4] != null then (glsl.sub radius, state.hs[4]) else 0,
            if state.hs[2] != null then (glsl.sub state.hs[2], radius) else if state.hs[5] != null then (glsl.sub radius, state.hs[5]) else 0]
          signs = [
            state.hs[0] == null and state.hs[3] != null,
            state.hs[1] == null and state.hs[4] != null,
            state.hs[2] == null and state.hs[5] != null]
          roComponents  = [
            if signs[0] then "-#{ro}.x" else "#{ro}.x", 
            if signs[1] then "-#{ro}.y" else "#{ro}.y", 
            if signs[2] then "-#{ro}.z" else "#{ro}.z"]
          roWithSigns = 
            if not (signs[0] or signs[1] or signs[2])
              "#{ro}"
            else if (signs[0] or state.hs[3] == null) and (signs[1] or state.hs[4] == null) and (signs[2] or state.hs[5] == null)
              "-#{ro}"
            else
              glslCompiler.preludeAdd flags.glslPrelude, "vec3(#{roComponents[0]}, #{roComponents[1]}, #{roComponents[2]})"
          cornerWithSigns = glsl.vec3Lit cornerSize
          dist = glslCompiler.preludeAdd flags.glslPrelude, "#{roWithSigns} - #{glsl.vec3Lit cornerSize}"
    
          # Special cases
          if cornerSpaces > 1
            if radius > 0
              state.codes.push primitiveCallback "length(max(#{dist}, 0.0)) - #{radius}", flags
            else if bevelRadius > 0
              axisCombinations = []
              axisCombinations.push 0 if state.hs[0] != null or state.hs[3] != null
              axisCombinations.push 1 if state.hs[1] != null or state.hs[4] != null
              axisCombinations.push 2 if state.hs[2] != null or state.hs[5] != null
              # TODO: assert(axisCombinations.length >= 2)
              glslCompiler.preludePush flags.glslPrelude, "#{roComponents[axisCombinations[0]]} + #{roComponents[axisCombinations[1]]} - #{cornerSize[axisCombinations[0]] + cornerSize[axisCombinations[1]] - bevelRadius}", "float"
              if axisCombinations.length == 3
                glslCompiler.preludePush flags.glslPrelude, "#{roComponents[axisCombinations[0]]} + #{roComponents[axisCombinations[2]]} - #{cornerSize[axisCombinations[0]] + cornerSize[axisCombinations[2]] - bevelRadius}", "float"
                glslCompiler.preludePush flags.glslPrelude, "#{roComponents[axisCombinations[1]]} + #{roComponents[axisCombinations[2]]} - #{cornerSize[axisCombinations[1]] + cornerSize[axisCombinations[2]] - bevelRadius}", "float"
              switch axisCombinations.length
                when 2
                  state.codes.push primitiveCallback "max(length(max(#{dist}, 0.0)), #{math_invsqrt2} * #{glslCompiler.preludePop flags.glslPrelude})", flags
                when 3
                  state.codes.push primitiveCallback "max(max(max(length(max(#{dist}, 0.0)), #{math_invsqrt2} * #{glslCompiler.preludePop flags.glslPrelude}), #{math_invsqrt2} * #{glslCompiler.preludePop flags.glslPrelude}), #{math_invsqrt2} * #{glslCompiler.preludePop flags.glslPrelude})", flags
            else # bevelRadius == chamferRadius == 0
              state.codes.push primitiveCallback "length(max(#{dist}, 0.0))", flags
            if state.hs[0] != null or state.hs[3] != null
              if state.hs[0] != null then state.hs[0] = null else state.hs[3] = null
            if state.hs[1] != null or state.hs[4] != null
              if state.hs[1] != null then state.hs[1] = null else state.hs[4] = null
            if state.hs[2] != null or state.hs[5] != null
              if state.hs[2] != null then state.hs[2] = null else state.hs[5] = null
            remainingHalfSpaces -= cornerSpaces
          else
            # General cases
            if state.hs[0] != null or state.hs[3] != null
              state.codes.push primitiveCallback "#{dist}.x", flags
              if state.hs[0] != null then state.hs[0] = null else state.hs[3] = null
            else if state.hs[1] != null or state.hs[4] != null
              state.codes.push primitiveCallback "#{dist}.y", flags
              if state.hs[1] != null then state.hs[1] = null else state.hs[4] = null
            else if state.hs[2] != null or state.hs[5] != null
              state.codes.push primitiveCallback "#{dist}.z", flags
              if state.hs[2] != null then state.hs[2] = null else state.hs[5] = null
            remainingHalfSpaces -= 1
        return
    */

    compileCompositeNode = function(name, cmpCallback, stack, node, flags) {
      var bevelRadius, c, chamferRadius, codes, collectCode, cornersState, h, ro, s, _i, _j, _k, _len, _len1, _len2, _ref;
      if (node.nodes.length === 0) {
        return;
      }
      codes = [];
      collectCode = function(codes, nodes) {
        var n, _i, _len;
        for (_i = 0, _len = nodes.length; _i < _len; _i++) {
          n = nodes[_i];
          if (n.code != null) {
            codes.push(n.code);
          }
          switch (n.type) {
            case 'translate':
            case 'rotate':
            case 'mirror':
            case 'repeat':
            case 'invert':
            case 'material':
            case 'chamfer':
            case 'bevel':
              collectCode(codes, n.nodes);
          }
        }
      };
      collectCode(codes, node.nodes);
      ro = glslCompiler.preludeTop(flags.glslPrelude);
      cornersState = {
        codes: [],
        hs: shallowClone(node.halfSpaces)
      };
      chamferRadius = 0;
      bevelRadius = 0;
      for (_i = 0, _len = stack.length; _i < _len; _i++) {
        s = stack[_i];
        switch (s.type) {
          case 'chamfer':
            chamferRadius = s.attr.radius;
            break;
          case 'bevel':
            bevelRadius = s.attr.radius;
            break;
          case 'translate':
          case 'rotate':
          case 'scale':
          case 'invert':
          case 'mirror':
          case 'repeat':
            continue;
        }
        break;
      }
      /* Compile the first and a possible second corner
      compileCorner ro, flags, cornersState, chamferRadius, bevelRadius
      compileCorner ro, flags, cornersState, chamferRadius, bevelRadius
      codes = codes.concat cornersState.codes
      #
      */

      _ref = cornersState.hs;
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        h = _ref[_j];
        if (!(h !== null)) {
          continue;
        }
        morpheus.logInternalError("GLSL Compiler: Post-condition failed, some half spaces were not processed during corner compilation.");
        break;
      }
      node.code = codes.shift();
      for (_k = 0, _len2 = codes.length; _k < _len2; _k++) {
        c = codes[_k];
        node.code = cmpCallback(c, node.code, flags);
      }
    };
    postDispatch = {
      invert: function(stack, node, flags) {
        flags.invert = !flags.invert;
        stack[0].nodes.push(node);
      },
      union: function(stack, node, flags) {
        flags.composition.pop();
        compileCompositeNode('Union', (!flags.invert ? minCallback : maxCallback), stack, node, flags);
        stack[0].nodes.push(node);
      },
      intersect: function(stack, node, flags) {
        flags.composition.pop();
        compileCompositeNode('Intersect', (!flags.invert ? maxCallback : minCallback), stack, node, flags);
        stack[0].nodes.push(node);
      },
      chamfer: function(stack, node, flags) {
        stack[0].nodes.push(node);
      },
      bevel: function(stack, node, flags) {
        stack[0].nodes.push(node);
      },
      translate: function(stack, node, flags) {
        glslCompiler.preludePop(flags.glslPrelude);
        if (node.nodes.length === 0) {
          morpheus.logInternalError("GLSL Compiler: Translate node is empty.");
          return;
        }
        stack[0].nodes.push(node);
      },
      rotate: function(stack, node, flags) {
        glslCompiler.preludePop(flags.glslPrelude);
        if (node.nodes.length === 0) {
          morpheus.logInternalError("GLSL Compiler: Rotate node is empty.");
          return;
        }
        stack[0].nodes.push(node);
      },
      scale: function(stack, node, flags) {
        if (flags.composition[flags.composition.length - 1] === glslCompiler.COMPOSITION_UNION) {
          compileCompositeNode('Scale', minCallback, stack, node, flags);
        } else if (flags.composition[flags.composition.length - 1] === glslCompiler.COMPOSITION_INTERSECT) {
          compileCompositeNode('Scale', maxCallback, stack, node, flags);
        }
        if (!Array.isArray(node.attr.factor)) {
          node.code = modifyCallback(node.code, glsl.mul("(" + node.code + ")", node.attr.factor));
        }
        glslCompiler.preludePop(flags.glslPrelude);
        stack[0].nodes.push(node);
      },
      mirror: function(stack, node, flags) {
        glslCompiler.preludePop(flags.glslPrelude);
        stack[0].nodes.push(node);
      },
      repeat: function(stack, node, flags) {
        glslCompiler.preludePop(flags.glslPrelude);
        stack[0].nodes.push(node);
      },
      halfspace: function(stack, node, flags) {
        var ro;
        if (node.nodes.length !== 0) {
          morpheus.logInternalError("GLSL Compiler: Halfspace node is not empty.");
          return;
        }
        ro = glslCompiler.preludeTop(flags.glslPrelude);
        if (flags.invert) {
          node.code = primitiveCallback(glsl.sub(node.attr.val, "" + ro + "[" + node.attr.axis + "]"), flags);
        } else {
          node.code = primitiveCallback(glsl.sub("" + ro + "[" + node.attr.axis + "]", node.attr.val), flags);
        }
        /* Generate half-space primitive when it cannot be compiled into a corner
        #if typeof node.attr.val == 'string'
        #  ro = glslCompiler.preludeTop flags.glslPrelude # Current ray origin
        #  if flags.invert
        #    node.code = primitiveCallback (glsl.sub node.attr.val, "#{ro}[#{node.attr.axis}]"), flags
        #  else
        #    node.code = primitiveCallback (glsl.sub "#{ro}[#{node.attr.axis}]", node.attr.val), flags
        #else
        # Bin half-spaces for corner compilation
        translateOffset = 0.0
        for s in stack
          if s.halfSpaces?
            # Assign to the halfspace bins for corner compilation
            index = node.attr.axis + (if flags.invert then 3 else 0)
            val = glsl.add node.attr.val, translateOffset
            s.halfSpaces[index] =
              if s.halfSpaces[index] == null
                 val
              else if flags.composition[flags.composition.length - 1] == glslCompiler.COMPOSITION_UNION
                if index < 3
                  glsl.max s.halfSpaces[index], val
                else
                  glsl.min s.halfSpaces[index], val
              else
                if index < 3
                  glsl.min s.halfSpaces[index], val
                else
                  glsl.max s.halfSpaces[index], val
          else
            switch s.type
              when 'translate'
                translateOffset = glsl.add translateOffset, s.attr.offset[node.attr.axis]
                continue # Search for preceding intersect/union node 
              when 'invert', 'mirror'
                continue # Search for preceding intersect/union node
              else
                # This may occur in special cases where we cannot do normal corner compilation
                # (Such as a separate transformation on the plane itself - with a wedge node for example)
                ro = glslCompiler.preludeTop flags.glslPrelude # Current ray origin
                if flags.invert
                  node.code = primitiveCallback (glsl.sub node.attr.val, "#{ro}[#{node.attr.axis}]"), flags
                else
                  node.code = primitiveCallback (glsl.sub "#{ro}[#{node.attr.axis}]", node.attr.val), flags
          break
        #
        */

        stack[0].nodes.push(node);
      },
      corner: function(stack, node, flags) {
        var bevelRadius, chamferRadius, cornerDist, cornerVal, diagonalDist, dist, ro, roSigned, s, _i, _len;
        ro = glslCompiler.preludeTop(flags.glslPrelude);
        dist = glslCompiler.preludeAdd(flags.glslPrelude, glsl.sub(ro, node.attr.val));
        chamferRadius = 0;
        bevelRadius = 0;
        for (_i = 0, _len = stack.length; _i < _len; _i++) {
          s = stack[_i];
          switch (s.type) {
            case 'chamfer':
              chamferRadius = s.attr.radius;
              break;
            case 'bevel':
              bevelRadius = s.attr.radius;
              break;
            case 'translate':
            case 'rotate':
            case 'scale':
            case 'invert':
            case 'mirror':
            case 'repeat':
              continue;
          }
          break;
        }
        if (bevelRadius !== 0) {
          roSigned = glslCompiler.preludeAdd(flags.glslPrelude, flags.invert ? "-" + ro : "" + ro);
          cornerVal = typeof node.attr.val === 'string' ? glslCompiler.preludeAdd(flags.glslPrelude, node.attr.val) : node.attr.val;
          diagonalDist = ["(" + roSigned + "[0] + " + roSigned + "[1] - (" + (glsl.add(glsl.index(cornerVal, 0), glsl.index(cornerVal, 1))) + "))", "(" + roSigned + "[0] + " + roSigned + "[2] - (" + (glsl.add(glsl.index(cornerVal, 0), glsl.index(cornerVal, 2))) + "))", "(" + roSigned + "[1] + " + roSigned + "[2] - (" + (glsl.add(glsl.index(cornerVal, 1), glsl.index(cornerVal, 2))) + "))"];
          if (flags.invert) {
            cornerDist = "length(min(" + dist + ", 0.0))";
            node.code = primitiveCallback("min(min(min(" + cornerDist + ", " + math_invsqrt2 + " * " + (glsl.index(diagonalDist, 0)) + " - " + bevelRadius + "), " + math_invsqrt2 + " * " + (glsl.index(diagonalDist, 1)) + " - " + bevelRadius + "), " + math_invsqrt2 + " * " + (glsl.index(diagonalDist, 2)) + " - " + bevelRadius + ")", flags);
          } else {
            cornerDist = "length(max(" + dist + ", 0.0))";
            node.code = primitiveCallback("max(max(max(" + cornerDist + ", " + math_invsqrt2 + " * " + (glsl.index(diagonalDist, 0)) + " + " + bevelRadius + "), " + math_invsqrt2 + " * " + (glsl.index(diagonalDist, 1)) + " + " + bevelRadius + "), " + math_invsqrt2 + " * " + (glsl.index(diagonalDist, 2)) + " + " + bevelRadius + ")", flags);
          }
        } else if (chamferRadius !== 0) {
          if (flags.invert) {
            node.code = primitiveCallback("length(min(" + (glsl.add(dist, chamferRadius)) + ", 0.0)) - " + chamferRadius, flags);
          } else {
            node.code = primitiveCallback("length(max(" + (glsl.add(dist, chamferRadius)) + ", 0.0)) - " + chamferRadius, flags);
          }
        } else {
          if (flags.invert) {
            node.code = primitiveCallback("length(min(" + dist + ", 0.0))", flags);
          } else {
            node.code = primitiveCallback("length(max(" + dist + ", 0.0))", flags);
          }
        }
        stack[0].nodes.push(node);
      },
      cylinder: function(stack, node, flags) {
        var planeCoords, ro;
        ro = glslCompiler.preludeTop(flags.glslPrelude);
        planeCoords = ['yz', 'xz', 'xy'][node.attr.axis];
        if (!flags.invert) {
          node.code = primitiveCallback(glsl.sub("length(" + ro + "." + planeCoords + ")", node.attr.radius), flags);
        } else {
          node.code = primitiveCallback(glsl.sub(node.attr.radius, "length(" + ro + "." + planeCoords + ")"), flags);
        }
        stack[0].nodes.push(node);
      },
      sphere: function(stack, node, flags) {
        var ro;
        ro = glslCompiler.preludeTop(flags.glslPrelude);
        if (!flags.invert) {
          node.code = primitiveCallback(glsl.sub("length(" + ro + ")", node.attr.radius), flags);
        } else {
          node.code = primitiveCallback(glsl.sub(node.attr.radius, "length(" + ro + ")"), flags);
        }
        stack[0].nodes.push(node);
      },
      material: function(stack, node, flags) {
        flags.materialIdStack.pop();
        stack[0].nodes.push(node);
      },
      "default": function(stack, node, flags) {
        stack[0].nodes.push(node);
      }
    };
    return (function(abstractSolidModel) {
      return glslCompiler(abstractSolidModel, preDispatch, postDispatch);
    });
  };

  glslSceneDistance = glslCompilerDistance((function(a) {
    return a;
  }), (function(a, b) {
    return "min(" + a + ", " + b + ")";
  }), (function(a, b) {
    return "max(" + a + ", " + b + ")";
  }), (function(oldVal, newVal) {
    return newVal;
  }));

  glslSceneId = glslCompilerDistance((function(a, flags) {
    var result;
    result = new toStringPrototype(a);
    result.materialId = flags.materialIdStack[flags.materialIdStack.length - 1];
    return result;
  }), (function(a, b, flags) {
    var id, memoA, memoB, result;
    memoA = glslCompiler.preludeAdd(flags.glslPrelude, String(a), 'float');
    memoB = glslCompiler.preludeAdd(flags.glslPrelude, String(b), 'float');
    id = glslCompiler.preludeAdd(flags.glslPrelude, "" + memoA + " < " + memoB + "? " + a.materialId + " : " + b.materialId, 'int');
    result = new toStringPrototype("" + memoA + " < " + memoB + "? " + memoA + " : " + memoB);
    result.materialId = id;
    return result;
  }), (function(a, b, flags) {
    var id, memoA, memoB, result;
    memoA = glslCompiler.preludeAdd(flags.glslPrelude, String(a), 'float');
    memoB = glslCompiler.preludeAdd(flags.glslPrelude, String(b), 'float');
    id = glslCompiler.preludeAdd(flags.glslPrelude, "" + memoA + " > " + memoB + "? " + a.materialId + " : " + b.materialId, 'int');
    result = new toStringPrototype("" + memoA + " > " + memoB + "? " + memoA + " : " + memoB);
    result.materialId = id;
    return result;
  }), (function(oldVal, newVal) {
    var result;
    result = new toStringPrototype(newVal);
    result.materialId = oldVal.materialId;
    return result;
  }));

  compileGLSL = safeExport('morpheus.editor.compileGLSL', ['', ''], function(abstractSolidModel, params) {
    var fragmentShader, rayDirection, rayOrigin, shaders, usePerspectiveProjection, vertexShader;
    rayOrigin = 'ro';
    rayDirection = 'rd';
    usePerspectiveProjection = false;
    /* TEMPORARY
    morpheus.logDebug "ASM:"
    morpheus.logDebug abstractSolidModel
    #
    */

    vertexShader = function() {
      var bounds, boundsResult, sceneTranslation;
      boundsResult = compileASMBounds(abstractSolidModel);
      if (!(boundsResult != null)) {
        return '';
      }
      if (boundsResult.nodes.length !== 1) {
        morpheus.logInternalError('GLSL Compiler: Expected exactly one result node from the bounding box compiler.');
        return '';
      }
      bounds = boundsResult.nodes[0].bounds;
      /* TEMPORARY
      morpheus.logDebug "Bounds Result:"
      morpheus.logDebug boundsResult
      #
      */

      sceneTranslation = [isFinite(bounds[0][0]) && isFinite(bounds[1][0]) ? bounds[0][0] + bounds[1][0] : '0.0', isFinite(bounds[0][1]) && isFinite(bounds[1][1]) ? bounds[0][1] + bounds[1][1] : '0.0', isFinite(bounds[0][2]) && isFinite(bounds[1][2]) ? bounds[0][2] + bounds[1][2] : '0.0'];
      return "const float Infinity = (1.0/0.0);\nconst vec3 sceneScale = vec3(" + (bounds[1][0] - bounds[0][0]) + ", " + (bounds[1][1] - bounds[0][1]) + ", " + (bounds[1][2] - bounds[0][2]) + ");\nconst vec3 sceneTranslation = vec3(" + sceneTranslation + ");\nuniform mat4 projection;\nuniform mat4 view;\nuniform mat3 model;\nattribute vec3 position;\nvarying vec3 modelPosition;\n" + (usePerspectiveProjection ? "varying vec3 viewPosition;" : "") + "\nvoid main(void) {\n  modelPosition = position;\n  " + (usePerspectiveProjection ? "viewPosition = (view * vec4(position, 1.0)).xyz;" : "") + "\n  gl_Position = projection * view * vec4(model * position, 1.0);\n}\n";
    };
    fragmentShader = function() {
      var distanceCode, distancePreludeCode, distanceResult, generateUniforms, idCode, idPreludeCode, idResult, sceneMaterial;
      distanceResult = glslSceneDistance(abstractSolidModel);
      if (!(distanceResult != null)) {
        return '';
      }
      if (distanceResult.nodes.length !== 1) {
        morpheus.logInternalError('GLSL Compiler: Expected exactly one result node from the distance compiler.');
      }
      /* TEMPORARY
      console.log "Distance Result:"
      console.log distanceResult
      #
      */

      idResult = glslSceneId(abstractSolidModel);
      if (idResult.nodes.length !== 1) {
        morpheus.logInternalError('GLSL Compiler: Expected exactly one result node from the material id compiler.');
      }
      /* TEMPORARY
      console.log "Id Result:"
      console.log idResult
      #
      */

      sceneMaterial = function(materials) {
        var binarySearch, i, m, result, _i, _ref;
        result = "\nvec3 sceneMaterial(in vec3 ro) {\n  int id = sceneId(ro);\n";
        /* Render the raw scene id as a grayscale value
        if materials.length > 0
          result += "  return vec3(float(id) * #{glsl.floatLit (1.0 / (materials.length - 1))});\n"
        else
          result += "  return vec3(0.5);\n"
        
        #
        */

        binarySearch = function(start, end) {
          var diff, mid;
          diff = end - start;
          if (diff === 1) {
            return "m" + start;
          } else {
            mid = start + Math.floor(diff * 0.5);
            return "(id < " + mid + "? " + (binarySearch(start, mid)) + " : " + (binarySearch(mid, end)) + ")";
          }
        };
        if (materials.length > 0) {
          for (i = _i = 0, _ref = materials.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            m = materials[i];
            result += "  vec3 m" + i + " = " + m + ";\n";
          }
          result += "  return id >= 0? " + (binarySearch(0, materials.length)) + " : vec3(0.5);\n";
        } else {
          result += "  return vec3(0.5);\n";
        }
        result += "}\n\n";
        return result;
      };
      generateUniforms = function(params) {
        var attr, generateUniform, name;
        generateUniform = function(attr) {
          var defaultValue, id, meta, type;
          id = attr[0], meta = attr[1], defaultValue = attr[2];
          type = (function() {
            switch (attr._tag) {
              case 'real':
              case 'dimension1':
              case 'pitch1':
              case 'angle':
                return 'float';
              case 'dimension2':
              case 'vector2':
              case 'point2':
              case 'pitch2':
              case 'polar':
              case 'cylindrical':
                return 'vec2';
              case 'dimension3':
              case 'vector3':
              case 'point3':
              case 'pitch3':
              case 'spherical':
                return 'vec3';
              case 'natural':
              case 'latice1':
                return 'float';
              case 'latice2':
                return 'vec2';
              case 'latice3':
                return 'vec3';
              default:
                return "(ERROR " + attr._tag + ")";
            }
          })();
          return ("uniform " + type + " " + name + ";") + (meta.description != null ? " // " + meta.description : "");
        };
        return ((function() {
          var _results;
          _results = [];
          for (name in params) {
            attr = params[name];
            switch (attr._tag) {
              case 'tolerance':
              case 'range':
                _results.push(generateUniform(attr[0]));
                break;
              default:
                _results.push(generateUniform(attr));
            }
          }
          return _results;
        })()).join('\n');
      };
      distanceCode = distanceResult.nodes[0].code;
      distancePreludeCode = distanceResult.flags.glslPrelude.code;
      idCode = idResult.nodes[0].code;
      idPreludeCode = idResult.flags.glslPrelude.code;
      return "#ifdef GL_ES\n  precision highp float;\n#endif\nconst float Infinity = (1.0/0.0);\nuniform mat4 view;\nuniform mat3 model;\nvarying vec3 modelPosition;\n" + (usePerspectiveProjection ? "varying vec3 viewPosition;" : "") + "\n\n" + (generateUniforms(params)) + "\n\n" + (glslLibrary.compile(distanceResult.flags.glslFunctions)) + "\n\nfloat sceneDist(in vec3 " + rayOrigin + ") {\n  " + (distancePreludeCode != null ? distancePreludeCode : '') + "\n  return max(0.0," + (distanceCode != null ? distanceCode : 'Infinity') + ");\n}\n\nvec3 sceneNormal(in vec3 p) {\n  const float eps = 0.00001;\n  vec3 n;\n  n.x = sceneDist( vec3(p.x+eps, p.yz) ) - sceneDist( vec3(p.x-eps, p.yz) );\n  n.y = sceneDist( vec3(p.x, p.y+eps, p.z) ) - sceneDist( vec3(p.x, p.y-eps, p.z) );\n  n.z = sceneDist( vec3(p.xy, p.z+eps) ) - sceneDist( vec3(p.xy, p.z-eps) );\n  return normalize(n);\n}\n\nint sceneId(in vec3 " + rayOrigin + ") {\n  " + (idPreludeCode != null ? idPreludeCode : '') + "\n  " + (idCode != null ? idCode + ';' : '') + "\n  return " + (idCode != null ? idCode.materialId : '-1') + ";\n}\n\n" + (sceneMaterial(idResult.flags.materials)) + "\n\nvoid main(void) {\n  // Constants\n  const int steps = 84;\n  const float threshold = 0.005;\n  \n  vec3 rayOrigin = modelPosition;\n  vec3 rayDir = vec3(0.0,0.0,-1.0) * mat3(view) * model;\n  vec3 prevRayOrigin = rayOrigin;\n  bool hit = false;\n  float dist = Infinity;\n  //float prevDist = (1.0/0.0);\n  //float bias = 0.0; // corrective bias for the step size\n  //float minDist = (1.0/0.0);\n  for(int i = 0; i < steps; i++) {\n    //dist = sceneRayDist(rayOrigin, rayDir);\n    //prevDist = dist;\n    dist = sceneDist(rayOrigin);\n    //minDist = min(minDist, dist);\n    if (dist <= 0.0) {\n      hit = true;\n      break;\n    }\n    prevRayOrigin = rayOrigin;\n    //rayOrigin += (max(dist, threshold) + bias) * rayDir;\n    rayOrigin += max(dist, threshold) * rayDir;\n    if (all(notEqual(clamp(rayOrigin, vec3(-1.0), vec3(1.0)), rayOrigin))) { break; }\n  }\n  vec3 absRayOrigin = abs(rayOrigin);\n  //if(!hit && max(max(absRayOrigin.x, absRayOrigin.y), absRayOrigin.z) >= 1.0) { discard; }\n  //if(!hit && prevDist >= dist) { discard; }\n  if(!hit && rayOrigin.z <= -1.0) { \n    // Get the z-plane intersection\n    const float floorOffset = 1.0; // For the bottom of the bounding box this should be 0.0\n    const float boundaryOffset = -0.5; // For a larger boundary > 0.0, or for a smaller boundary < 0.0\n    const float shadeFactor = 0.45; // Shading factor (1.0 for full shader)\n    float dz = (modelPosition.z + 1.0) / -rayDir.z;\n    vec3 pz = modelPosition + rayDir * dz;\n    pz.z += floorOffset;\n    float shade = max(0.0, 1.0 + boundaryOffset - max(0.0,sceneDist(pz)));\n    gl_FragColor = vec4(0.0,0.0,0.0,max(0.0, shadeFactor*shade*shade*shade));\n  }\n  else if (!hit) {\n    discard;\n  }\n  else {\n    //if (!hit) { discard; }\n    //if(!hit) { gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); return; }\n    //const vec3 diffuseColor = vec3(0.1, 0.2, 0.8);\n    vec3 diffuseColor = sceneMaterial(prevRayOrigin);\n    //const vec3 specularColor = vec3(1.0, 1.0, 1.0);\n          \n    // Lighting parameters\n    const float specularFactor = 0.3;\n    const float specularPhongShininess = 10.0;\n    const vec3 lightPos = vec3(1.5,2.5, 4.0);\n    vec3 lightDir = normalize(lightPos - prevRayOrigin);\n    vec3 normal = sceneNormal(prevRayOrigin);\n\n    //* Diffuse shading\n    float diffuse = dot(normal, lightDir);\n    //*/\n    //* Phong reflection model\n    vec3 reflectDir = reflect(-rayDir, normal);\n    vec3 specular = vec3(specularFactor * pow(max(dot(reflectDir, rayDir), 0.0), specularPhongShininess));\n    //*/\n\n    //* Regular shading\n    const float ambientFactor = 0.7;\n    const float diffuseFactor = 1.0 - ambientFactor;\n    diffuse = ambientFactor + diffuse * diffuseFactor;\n    //*/\n\n    /* Cel shading\n    const float cellA = 0.3;\n    const float cellB = 0.4;\n    const float cellC = 0.5;\n    const float cellD = 1.0 - cellA;\n    diffuse = cellA + max(step(cellA, diffuse)*cellA, max(step(cellB, diffuse)*cellB, max(step(cellC, diffuse)*cellC, step(cellD, diffuse)*cellD)));\n    //*/\n\n    //* Ambient occlusion\n    const float aoIterations = 5.0;\n    const float aoFactor = 2.0;\n    const float aoDistanceFactor = 1.6;\n    const float aoDistanceDelta = 0.1 / 5.0;\n    float ao = 1.0;\n    float invPow2 = 1.0;\n    vec3 aoDirDist = normal * aoDistanceDelta;\n    vec3 aoPos = prevRayOrigin;\n    for (float i = 1.0; i < (aoIterations + 1.0);  i += 1.0) {\n      invPow2 *= aoDistanceFactor * 0.5;\n      aoPos += aoDirDist;\n      ao -= aoFactor * invPow2 * (i * aoDistanceDelta - sceneDist(aoPos));\n    }\n    diffuse *= max(ao, 0.0);\n    //*/\n    \n    gl_FragColor = vec4(diffuseColor * diffuse + specular, 1.0);\n  }\n}\n";
    };
    shaders = [vertexShader(), fragmentShader()];
    return shaders;
  });

  exports = exports != null ? exports : {};

  exports.translateCSM = translateCSM;

  exports.compileASM = compileASM;

  exports.compileGLSL = compileGLSL;

  return exports;

}).call(this);


/*
 * Copyright 2011-2013, CircuitHub.com
 */
var morpheus = morpheus || {}; /* Redeclaring morpheus is fine: behaves like a no-op (https://developer.mozilla.org/en/JavaScript/Reference/Scope_Cheatsheet) */

morpheus.editor = 
// Generated by CoffeeScript 1.4.0
(function() {
  "use strict";

  var create, exports, getSourceCode, safeExport, safeTry, translateSugaredJS;

  morpheus.log = ((typeof console !== "undefined" && console !== null) && (console.log != null) ? function() {
    return console.log.apply(console, arguments);
  } : function() {});

  morpheus.logDebug = ((typeof morpheusDebug !== "undefined" && morpheusDebug !== null) && morpheusDebug && (typeof console !== "undefined" && console !== null) && (console.log != null) ? function() {
    return console.log.apply(console, arguments);
  } : function() {});

  morpheus.logInternalError = ((typeof console !== "undefined" && console !== null) && (console.error != null) ? function() {
    return console.error.apply(console, arguments);
  } : function() {});

  morpheus.logApiError = ((typeof console !== "undefined" && console !== null) && (console.error != null) ? function() {
    return console.error.apply(console, arguments);
  } : function() {});

  morpheus.logApiWarning = ((typeof console !== "undefined" && console !== null) && (console.warn != null) ? function() {
    return console.warn.apply(console, arguments);
  } : function() {});

  morpheus.logException = function(locationName, error) {
    var logArgs;
    logArgs = ["Uncaught exception in `" + locationName + "`:\n"];
    logArgs.push((error.message != null ? "" + error.message + "\n" : error));
    if (error.stack != null) {
      logArgs.push(error.stack);
    }
    morpheus.logInternalError.apply(morpheus, logArgs);
  };

  safeExport = function(name, errorValue, callback) {
    return safeTry(name, callback, function(error) {
      morpheus.logException(name, error);
      return errorValue;
    });
  };

  safeTry = function(name, callback, errorCallback) {
    if ((typeof morpheusDebug !== "undefined" && morpheusDebug !== null) && morpheusDebug) {
      return callback;
    } else {
      return function() {
        try {
          return callback.apply(null, arguments);
        } catch (error) {
          return errorCallback(error);
        }
      };
    }
  };

  translateSugaredJS = function(csmSourceCode) {
    return csmSourceCode;
  };

  create = safeExport('morpheus.editor.create', void 0, function(containerSelector, sourceCode) {
    if (!(sourceCode != null)) {
      sourceCode = "";
    }
    ($(containerSelector)).html("<span><input class='morpheus-source-autocompile' name='morpheus-source-autocompile' type='checkbox' disabled='disabled'><label class='morpheus-source-autocompile-label' for='morpheus-source-autocompile'>Auto-compile</label></span>\n<input class='morpheus-source-compile' name='morpheus-source-compile' type='button' value='Compile'>\n<textarea class='morpheus-source-code' name='morpheus-source-code'>\n" + sourceCode + "\n</textarea>");
  });

  getSourceCode = safeExport('morpheus.editor.getSourceCode', '', function(containerSelector) {
    return (($(containerSelector != null ? containerSelector : document)).find('.morpheus-source-code')).val();
  });

  exports = exports != null ? exports : {};

  exports.create = create;

  exports.getSourceCode = getSourceCode;

  return exports;

}).call(this);


/*
 * Copyright 2011-2013, CircuitHub.com
 */
var morpheus = morpheus || {}; /* Redeclaring morpheus is fine: behaves like a no-op (https://developer.mozilla.org/en/JavaScript/Reference/Scope_Cheatsheet) */

morpheus.renderer = 
// Generated by CoffeeScript 1.4.0
(function() {
  "use strict";

  var clearColor, createScene, exports, gl, math_degToRad, math_invsqrt2, math_radToDeg, math_sqrt2, modelArguments, modelRotate, modelShaders, runScene, safeExport, safeTry, state,
    __slice = [].slice;

  math_sqrt2 = Math.sqrt(2.0);

  math_invsqrt2 = 1.0 / math_sqrt2;

  math_degToRad = Math.PI / 180.0;

  math_radToDeg = 180.0 / Math.PI;

  Math.clamp = function(s, min, max) {
    return Math.min(Math.max(s, min), max);
  };

  morpheus.log = ((typeof console !== "undefined" && console !== null) && (console.log != null) ? function() {
    return console.log.apply(console, arguments);
  } : function() {});

  morpheus.logDebug = ((typeof morpheusDebug !== "undefined" && morpheusDebug !== null) && morpheusDebug && (typeof console !== "undefined" && console !== null) && (console.log != null) ? function() {
    return console.log.apply(console, arguments);
  } : function() {});

  morpheus.logInternalError = ((typeof console !== "undefined" && console !== null) && (console.error != null) ? function() {
    return console.error.apply(console, arguments);
  } : function() {});

  morpheus.logApiError = ((typeof console !== "undefined" && console !== null) && (console.error != null) ? function() {
    return console.error.apply(console, arguments);
  } : function() {});

  morpheus.logApiWarning = ((typeof console !== "undefined" && console !== null) && (console.warn != null) ? function() {
    return console.warn.apply(console, arguments);
  } : function() {});

  morpheus.logException = function(locationName, error) {
    var logArgs;
    logArgs = ["Uncaught exception in `" + locationName + "`:\n"];
    logArgs.push((error.message != null ? "" + error.message + "\n" : error));
    if (error.stack != null) {
      logArgs.push(error.stack);
    }
    morpheus.logInternalError.apply(morpheus, logArgs);
  };

  safeExport = function(name, errorValue, callback) {
    return safeTry(name, callback, function(error) {
      morpheus.logException(name, error);
      return errorValue;
    });
  };

  safeTry = function(name, callback, errorCallback) {
    if ((typeof morpheusDebug !== "undefined" && morpheusDebug !== null) && morpheusDebug) {
      return callback;
    } else {
      return function() {
        try {
          return callback.apply(null, arguments);
        } catch (error) {
          return errorCallback(error);
        }
      };
    }
  };

  gl = glQuery;

  state = {
    canvas: null,
    context: null,
    nextFrame: null,
    shader: {
      program: null,
      vs: null,
      fs: null
    },
    rotation: [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0],
    clearColor: [0.2, 0.2, 0.2, 1.0]
  };

  modelShaders = safeExport('morpheus.renderer.modelShaders', false, function(modelName, shaders) {
    var success;
    success = true;
    if (!(state.context != null)) {
      throw "WebGL context is not available.";
    }
    if (!(shaders != null) || shaders.length < 2 || shaders[0].length === 0 || shaders[1].length === 0) {
      return;
    }
    if (!(state.shader.program != null)) {
      state.shader.program = state.context.createProgram();
      state.shader.vs = state.context.createShader(state.context.VERTEX_SHADER);
      state.context.attachShader(state.shader.program, state.shader.vs);
      state.shader.fs = state.context.createShader(state.context.FRAGMENT_SHADER);
      state.context.attachShader(state.shader.program, state.shader.fs);
    }
    state.context.shaderSource(state.shader.vs, shaders[0]);
    state.context.shaderSource(state.shader.fs, shaders[1]);
    state.context.compileShader(state.shader.vs);
    if (!state.context.getShaderParameter(state.shader.vs, state.context.COMPILE_STATUS)) {
      morpheus.logApiError("Shader compile failed:\n" + (state.context.getShaderInfoLog(state.shader.vs)) + "\n" + shaders[0]);
    }
    state.context.compileShader(state.shader.fs);
    if (!state.context.getShaderParameter(state.shader.fs, state.context.COMPILE_STATUS)) {
      morpheus.logApiError("Shader compile failed:\n" + (state.context.getShaderInfoLog(state.shader.fs)) + "\n" + shaders[1]);
    }
    state.context.linkProgram(state.shader.program);
    if (!state.context.getProgramParameter(state.shader.program, state.context.LINK_STATUS)) {
      morpheus.logApiError("Shader link failed:\n" + (state.context.getProgramInfoLog(state.shader.progam)));
    }
    (gl('scene')).shaderProgram(state.shader.program);
    gl.refresh(state.shader.program);
    return success;
  });

  modelArguments = safeExport('morpheus.renderer.modelArguments', void 0, function(modelName, args, params) {
    var arg, i, id, nom, param, paramToUniform, uniformID, unwrap, x, _ref;
    unwrap = function(data) {
      switch (data._tag) {
        case 'tolerance':
        case 'range':
          return data[0];
        default:
          return data;
      }
    };
    paramToUniform = {};
    if (params != null) {
      for (uniformID in params) {
        param = params[uniformID];
        id = unwrap(param)[0];
        paramToUniform[id] = uniformID;
      }
    }
    for (id in args) {
      arg = args[id];
      uniformID = (_ref = paramToUniform[id]) != null ? _ref : id;
      if ((!Array.isArray(arg)) && (typeof arg === 'object') && (arg.min != null) && (arg.max != null)) {
        nom = null;
        if (Array.isArray(arg.min)) {
          nom = (function() {
            var _i, _len, _ref1, _results;
            _ref1 = arg.min;
            _results = [];
            for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
              x = _ref1[i];
              _results.push((x + arg.max[i]) * 0.5);
            }
            return _results;
          })();
        } else {
          nom = (arg.min + arg.max) * 0.5;
        }
        (gl(modelName)).uniform(uniformID, nom);
      } else {
        (gl(modelName)).uniform(uniformID, arg);
      }
    }
  });

  modelRotate = safeExport('morpheus.renderer.modelRotate', void 0, function(modelName, angles) {
    gl.matrix3.rotateZY(state.rotation, state.rotation, angles);
    (gl(modelName)).uniform('model', state.rotation);
  });

  createScene = safeExport('morpheus.renderer.createScene', void 0, function(context) {
    var indices, positions;
    state.context = context;
    positions = [1.0, 1.0, -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0];
    indices = [0, 1, 2, 0, 2, 3, 4, 7, 6, 4, 6, 5, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23];
    if ((state.vbo != null)) {
      context.deleteBuffer(state.vbo);
    }
    if ((state.ibo != null)) {
      context.deleteBuffer(state.ibo);
    }
    state.vbo = context.createBuffer();
    context.bindBuffer(context.ARRAY_BUFFER, state.vbo);
    context.bufferData(context.ARRAY_BUFFER, new Float32Array(positions), context.STATIC_DRAW);
    state.ibo = context.createBuffer();
    context.bindBuffer(context.ELEMENT_ARRAY_BUFFER, state.ibo);
    context.bufferData(context.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), context.STATIC_DRAW);
    gl.scene({
      'scene': ''
    }).vertexAttrib('position', state.vbo, 9 * 8, gl.FLOAT, 3, false, 0, 0).vertexElem(state.ibo, 6 * 6, gl.UNSIGNED_SHORT, 0).uniform('view', gl.matrix4.newLookAt([10.0, 10.0, 10.0], [0.0, 0.0, 0.0], [0.0, 0.0, 1.0])).uniform('projection', gl.matrix4.newOrtho(-math_sqrt2, math_sqrt2, -math_sqrt2, math_sqrt2, 0.1, 100.0)).uniform('model', state.rotation).triangles();
  });

  runScene = safeExport('morpheus.renderer.runScene', void 0, function(idleCallback) {
    var canvas, _gl;
    _gl = state.context;
    _gl.cullFace(_gl.BACK);
    _gl.enable(_gl.CULL_FACE);
    _gl.enable(_gl.BLEND);
    _gl.blendFuncSeparate(_gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA, _gl.ZERO, _gl.ONE);
    canvas = gl.canvas(state.context);
    canvas.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT).clearColor.apply(canvas, state.clearColor).start('scene', null, null, idleCallback);
  });

  clearColor = function(r, g, b, a) {
    state.clearColor = __slice.call(arguments);
    if (state.context != null) {
      return (gl.canvas(state.context)).clearColor(r, g, b, a);
    }
  };

  exports = exports != null ? exports : {};

  exports.createScene = createScene;

  exports.runScene = runScene;

  exports.modelShaders = modelShaders;

  exports.modelArguments = modelArguments;

  exports.modelRotate = modelRotate;

  exports.clearColor = clearColor;

  exports.getRenderingContext = function() {
    return state.context;
  };

  return exports;

}).call(this);


/*
 * Copyright 2011-2013, CircuitHub.com
 */
var morpheus = morpheus || {}; /* Redeclaring morpheus is fine: behaves like a no-op (https://developer.mozilla.org/en/JavaScript/Reference/Scope_Cheatsheet) */

morpheus.gui = 
// Generated by CoffeeScript 1.4.0
(function() {
  "use strict";

  var apiInit, canvasInit, constants, controlsArgumentsUpdate, controlsInit, controlsSourceCompile, create, createControls, createEditor, getModelArguments, getModelParameters, gl, init, keyDown, math_degToRad, math_invsqrt2, math_radToDeg, math_sqrt2, mouseCoordsWithinElement, mouseDown, mouseMove, mouseUp, mouseWheel, registerControlEvents, registerDOMEvents, registerEditorEvents, result, safeExport, safeTry, sceneIdle, sceneReset, sceneScript, setModelArguments, state, windowResize, wrapParams,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  math_sqrt2 = Math.sqrt(2.0);

  math_invsqrt2 = 1.0 / math_sqrt2;

  math_degToRad = Math.PI / 180.0;

  math_radToDeg = 180.0 / Math.PI;

  Math.clamp = function(s, min, max) {
    return Math.min(Math.max(s, min), max);
  };

  morpheus.log = ((typeof console !== "undefined" && console !== null) && (console.log != null) ? function() {
    return console.log.apply(console, arguments);
  } : function() {});

  morpheus.logDebug = ((typeof morpheusDebug !== "undefined" && morpheusDebug !== null) && morpheusDebug && (typeof console !== "undefined" && console !== null) && (console.log != null) ? function() {
    return console.log.apply(console, arguments);
  } : function() {});

  morpheus.logInternalError = ((typeof console !== "undefined" && console !== null) && (console.error != null) ? function() {
    return console.error.apply(console, arguments);
  } : function() {});

  morpheus.logApiError = ((typeof console !== "undefined" && console !== null) && (console.error != null) ? function() {
    return console.error.apply(console, arguments);
  } : function() {});

  morpheus.logApiWarning = ((typeof console !== "undefined" && console !== null) && (console.warn != null) ? function() {
    return console.warn.apply(console, arguments);
  } : function() {});

  morpheus.logException = function(locationName, error) {
    var logArgs;
    logArgs = ["Uncaught exception in `" + locationName + "`:\n"];
    logArgs.push((error.message != null ? "" + error.message + "\n" : error));
    if (error.stack != null) {
      logArgs.push(error.stack);
    }
    morpheus.logInternalError.apply(morpheus, logArgs);
  };

  safeExport = function(name, errorValue, callback) {
    return safeTry(name, callback, function(error) {
      morpheus.logException(name, error);
      return errorValue;
    });
  };

  safeTry = function(name, callback, errorCallback) {
    if ((typeof morpheusDebug !== "undefined" && morpheusDebug !== null) && morpheusDebug) {
      return callback;
    } else {
      return function() {
        try {
          return callback.apply(null, arguments);
        } catch (error) {
          return errorCallback(error);
        }
      };
    }
  };

  gl = glQuery;

  constants = {
    canvas: {
      defaultSize: [512, 512]
    },
    camera: {
      maxOrbitSpeed: Math.PI * 0.1,
      orbitSpeedFactor: 0.05,
      zoomSpeedFactor: 0.5
    }
  };

  state = {
    scene: null,
    canvas: null,
    viewport: {
      domElement: null,
      mouse: {
        last: [0, 0],
        leftDown: false,
        middleDown: false,
        leftDragDistance: 0,
        middleDragDistance: 0
      }
    },
    editor: {
      domElement: null
    },
    parameters: {
      domElement: null
    },
    api: {
      url: null,
      sourceCode: null
    },
    application: {
      initialized: false,
      sceneInitialized: false
    },
    models: {},
    paths: {
      morpheusUrlRoot: null,
      jsandboxUrl: null
    }
  };

  mouseCoordsWithinElement = function(event) {
    var coords, element, totalOffsetLeft, totalOffsetTop;
    coords = [0, 0];
    if (!event) {
      event = window.event;
      coords = [event.x, event.y];
    } else {
      element = event.target;
      totalOffsetLeft = 0;
      totalOffsetTop = 0;
      while (element.offsetParent) {
        totalOffsetLeft += element.offsetLeft;
        totalOffsetTop += element.offsetTop;
        element = element.offsetParent;
      }
      coords = [event.pageX - totalOffsetLeft, event.pageY - totalOffsetTop];
    }
    return coords;
  };

  sceneScript = safeExport('morpheus.gui: sceneScript', void 0, function(morpheusScriptCode, callback) {
    var csmSourceCode, requestId;
    csmSourceCode = morpheus.generator.translateCSM(state.api.sourceCode, morpheusScriptCode);
    requestId = JSandbox["eval"]({
      data: csmSourceCode,
      callback: function(result) {
        var defaultValue, id, meta, model, oldParam, param, params, uniformID, unwrap, _base, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
        morpheus.logDebug(result);
        if ((_ref = (_base = state.models).scene) == null) {
          _base.scene = {
            shaders: [],
            params: {},
            args: {}
          };
        }
        model = state.models.scene;
        params = (_ref1 = result != null ? (_ref2 = result.attr) != null ? _ref2.params : void 0 : void 0) != null ? _ref1 : {};
        unwrap = function(data) {
          switch (data._tag) {
            case 'tolerance':
            case 'range':
              return data[0];
            default:
              return data;
          }
        };
        _ref3 = model.params;
        for (uniformID in _ref3) {
          oldParam = _ref3[uniformID];
          param = params[uniformID];
          if (!(param != null) || param._tag !== oldParam._tag) {
            _ref4 = unwrap(param != null ? param : oldParam), id = _ref4[0], meta = _ref4[1], defaultValue = _ref4[2];
            delete model.args[id];
          }
        }
        for (uniformID in params) {
          param = params[uniformID];
          _ref5 = unwrap(param), id = _ref5[0], meta = _ref5[1], defaultValue = _ref5[2];
          if (!(__indexOf.call(model.args, id) >= 0)) {
            model.args[id] = defaultValue;
          }
        }
        model.params = params;
        model.shaders = morpheus.generator.compileGLSL(morpheus.generator.compileASM(result), model.params);
        morpheus.renderer.modelShaders('scene', model.shaders);
        morpheus.gui.setModelArguments('scene', model.args);
        controlsInit();
        state.application.sceneInitialized = true;
        if (typeof callback === "function") {
          callback();
        }
      },
      onerror: function(data, request) {
        morpheus.logInternalError("Error compiling the solid model.");
        if (typeof callback === "function") {
          callback("Error compiling the solid model.");
        }
      }
    });
  });

  sceneReset = safeExport('morpheus.gui: sceneReset', void 0, function() {
    return state.models['scene'] = {
      shaders: [],
      params: {},
      args: {}
    };
  });

  windowResize = safeExport('morpheus.gui: windowResize', void 0, function() {});

  mouseDown = safeExport('morpheus.gui: mouseDown', void 0, function(event) {
    state.viewport.mouse.last = [event.clientX, event.clientY];
    switch (event.which) {
      case 1:
        return state.viewport.mouse.leftDown = true;
      case 2:
        return state.viewport.mouse.middleDown = true;
    }
    /* Pick the object under the mouse
    if not state.scene?
      return
    if event.which == 1 # Left mouse button
      coords = mouseCoordsWithinElement event
      state.viewport.mouse.pickRecord = state.scene.pick coords[0], coords[1]
    */

  });

  mouseUp = safeExport('morpheus.gui: mouseUp', void 0, function(event) {
    switch (event.which) {
      case 1:
        state.viewport.mouse.leftDown = false;
        state.viewport.mouse.leftDragDistance = 0;
        break;
      case 2:
        state.viewport.mouse.middleDown = false;
        state.viewport.mouse.middleDragDistance = 0;
    }
  });

  mouseMove = function(event) {
    return safeTry("morpheus.gui: mouseMove", (function() {
      var delta, deltaLength, orbitAngles;
      delta = [event.clientX - state.viewport.mouse.last[0], event.clientY - state.viewport.mouse.last[1]];
      deltaLength = gl.vec2.length(delta);
      if (state.viewport.mouse.leftDown) {
        state.viewport.mouse.leftDragDistance += deltaLength;
      }
      if (state.viewport.mouse.middleDown) {
        state.viewport.mouse.middleDragDistance += deltaLength;
      }
      if (state.viewport.mouse.leftDown && event.which === 1) {
        orbitAngles = [0.0, 0.0];
        gl.vec2.mul(orbitAngles, delta, constants.camera.orbitSpeedFactor / deltaLength);
        orbitAngles = [Math.clamp(orbitAngles[0], -constants.camera.maxOrbitSpeed, constants.camera.maxOrbitSpeed), Math.clamp(orbitAngles[1], -constants.camera.maxOrbitSpeed, constants.camera.maxOrbitSpeed)];
        if ((isNaN(orbitAngles[0])) || (Math.abs(orbitAngles[0])) === Infinity) {
          orbitAngles[0] = 0.0;
        }
        if ((isNaN(orbitAngles[1])) || (Math.abs(orbitAngles[1])) === Infinity) {
          orbitAngles[1] = 0.0;
        }
        morpheus.renderer.modelRotate('scene', orbitAngles);
      }
      return state.viewport.mouse.last = [event.clientX, event.clientY];
    }), (function(error) {}))();
  };

  mouseWheel = safeExport('morpheus.gui: mouseWheel', void 0, function(event) {
    var delta, zoomDistance;
    delta = event.wheelDelta != null ? event.wheelDelta / -120.0 : Math.clamp(event.detail, -1.0, 1.0);
    zoomDistance = delta * constants.camera.zoomSpeedFactor;
  });

  keyDown = safeExport('morpheus.gui: keyDown', void 0, function(event) {});

  controlsSourceCompile = safeExport('morpheus.gui.controlsSourceCompile', void 0, function() {
    morpheus.gui.sceneScript(morpheus.editor.getSourceCode(state.editor.domElement), function(error) {
      if (error != null) {
        console.error(error);
      }
    });
  });

  controlsArgumentsUpdate = safeExport('morpheus.gui.controlsArgumentsUpdate', void 0, function(event) {
    setModelArguments('scene', parameterize.get(state.parameters.domElement, getModelParameters('scene')));
  });

  registerDOMEvents = function() {
    ($('#morpheus-gui')).on('mousedown', '#morpheus-canvas', mouseDown);
    state.viewport.domElement.addEventListener('mouseup', mouseUp, true);
    state.viewport.domElement.addEventListener('mousemove', mouseMove, true);
    state.viewport.domElement.addEventListener('mousewheel', mouseWheel, true);
    state.viewport.domElement.addEventListener('DOMMouseScroll', mouseWheel, true);
    document.addEventListener('keydown', keyDown, true);
    return window.addEventListener('resize', windowResize, true);
  };

  registerEditorEvents = function() {
    var $container;
    $container = $(state.editor.domElement);
    return ($container.find('.morpheus-source-compile')).on('click', controlsSourceCompile);
  };

  registerControlEvents = function() {
    return parameterize.on('update', state.parameters.domElement, controlsArgumentsUpdate);
  };

  sceneIdle = function() {
    return safeTry("morpheus.gui: sceneIdle", (function() {}), (function(error) {}))();
  };

  canvasInit = function() {
    return windowResize();
  };

  controlsInit = safeExport('morpheus.gui: controlsInit', void 0, function() {
    var c, controls, el, model, modelName, roundDecimals, _i, _len;
    roundDecimals = function(n) {
      var nonzeroDigits, parts, zeroDigits;
      parts = (String(n)).split('.');
      if (parts.length === 1) {
        return parts[0];
      }
      nonzeroDigits = parts[1].match(/[1-9]+/g);
      zeroDigits = parts[1].match(/^0+/);
      if (nonzeroDigits.length === 0) {
        return parts[0];
      }
      if (zeroDigits.length > 0) {
        return "" + parts[0] + "." + zeroDigits[0] + nonzeroDigits[0];
      }
      return "" + parts[0] + "." + nonzeroDigits[0];
    };
    el = state.parameters.domElement;
    if (el != null) {
      controls = (function() {
        var _ref, _results;
        _ref = state.models;
        _results = [];
        for (modelName in _ref) {
          model = _ref[modelName];
          _results.push(parameterize.html(getModelParameters(modelName)));
        }
        return _results;
      })();
      el.innerHTML = "";
      for (_i = 0, _len = controls.length; _i < _len; _i++) {
        c = controls[_i];
        el.appendChild(c);
      }
    }
  });

  apiInit = function(morpheusScriptCode, callback) {
    var $apiLink;
    $apiLink = $("link[rel='api']");
    if (typeof state.paths.morpheusUrlRoot === 'string') {
      state.api.url = state.paths.morpheusUrlRoot.length === 0 || state.paths.morpheusUrlRoot[state.paths.morpheusUrlRoot.length - 1] === '/' ? state.paths.morpheusUrlRoot + 'morpheus-api.min.js' : state.paths.morpheusUrlRoot + '/morpheus-api.min.js';
    } else if ($apiLink.length > 0) {
      state.api.url = $apiLink.attr('href');
    } else {
      state.api.url = 'morpheus-api.min.js';
    }
    return ($.get(state.api.url, void 0, void 0, 'text')).success(function(data, textStatus, jqXHR) {
      state.api.sourceCode = data;
      morpheus.log("Loaded " + state.api.url);
      return typeof callback === "function" ? callback(morpheusScriptCode) : void 0;
    }).error(function() {
      return morpheus.log("Error loading API script");
    });
  };

  init = function(containerEl, canvasEl, callback) {
    var morpheusScriptCode, _ref, _ref1;
    state.viewport.domElement = containerEl;
    state.canvas = canvasEl;
    if (state.canvas != null) {
      state.scene = morpheus.renderer.createScene(state.canvas.getContext('experimental-webgl'));
      morpheus.renderer.runScene(null);
    }
    canvasInit();
    morpheusScriptCode = (_ref = (_ref1 = morpheus.editor) != null ? _ref1.getSourceCode(state.editor.domElement) : void 0) != null ? _ref : "";
    apiInit(morpheusScriptCode, function() {
      if (typeof callback === "function") {
        callback();
      }
      if (!state.application.sceneInitialized) {
        return sceneScript(morpheusScriptCode);
      }
    });
    registerDOMEvents();
    return state.application.initialized = true;
  };

  create = safeExport('morpheus.gui.create', false, function(container, jsandboxUrl, morpheusUrlRoot, fixedWidth, fixedHeight, callback) {
    var containerEl, errorHtml;
    errorHtml = "<div>Could not create Morpheus GUI. Please see the console for error messages.</div>";
    if (!(fixedWidth != null)) {
      fixedWidth = 512;
    }
    if (!(fixedHeight != null)) {
      fixedHeight = 512;
    }
    if (container !== null && typeof container !== 'string' && (typeof container !== 'object' || container.nodeName !== 'DIV')) {
      containerEl.innerHTML = errorHtml;
      morpheus.logApiError("Morpheus GUI: (ERROR) Invalid container selector '" + container + "' supplied, expected type 'string' or dom element of type 'DIV'.");
      return false;
    } else if (container === null) {
      morpheus.logApiWarning("Morpheus GUI: (WARNING) No container element supplied. Creating a div element here...");
    } else {
      containerEl = typeof container === 'string' ? document.querySelector(container) : container;
    }
    if (containerEl === null || containerEl.nodeName !== 'DIV') {
      morpheus.logApiError("Morpheus GUI: (ERROR) Invalid container selector '" + container + "' supplied, could not find a matching 'DIV' element in the document.");
      return false;
    }
    containerEl.innerHTML = ("<canvas id='morpheus-canvas' width='" + fixedWidth + "' height='" + fixedHeight + "'>\n  <p>This application requires a browser that supports the<a href='http://www.w3.org/html/wg/html5/'>HTML5</a>&lt;canvas&gt; feature.</p>\n</canvas>") + containerEl.innerHTML;
    if (jsandboxUrl != null) {
      state.paths.jsandboxUrl = jsandboxUrl;
    }
    if (morpheusUrlRoot != null) {
      state.paths.morpheusUrlRoot = morpheusUrlRoot;
    }
    if (state.paths.jsandboxUrl != null) {
      JSandbox.create(state.paths.jsandboxUrl);
    }
    init(containerEl, document.getElementById('morpheus-canvas'), callback);
    return true;
  });

  createControls = safeExport('morpheus.gui.createControls', false, function(container) {
    var containerEl;
    if (container !== null && typeof container !== 'string' && (typeof container !== 'object' || container.nodeName !== 'DIV')) {
      morpheus.logApiError("Morpheus GUI: (ERROR) Invalid container selector '" + container + "' supplied, expected type 'string' or dom element of type 'DIV'.");
      return false;
    } else if (container === null) {
      morpheus.logApiWarning("Morpheus GUI: (WARNING) No container element supplied. Creating a div element here...");
    } else {
      containerEl = typeof container === 'string' ? document.querySelector(container) : container;
    }
    if (containerEl === null || containerEl.nodeName !== 'DIV') {
      morpheus.logApiError("Morpheus GUI: (ERROR) Invalid container id '" + container + "' supplied, could not find a matching 'DIV' element in the document.");
      return false;
    }
    if (!(state.parameters.domElement != null)) {
      state.parameters.domElement = containerEl;
    }
    controlsInit();
    registerControlEvents();
    return true;
  });

  createEditor = safeExport('morpheus.gui.createEditor', false, function(container, sourceCode) {
    morpheus.editor.create(container, sourceCode);
    state.editor.domElement = container;
    registerEditorEvents();
    return true;
  });

  wrapParams = function(params) {
    var name, param, _ref;
    return parameterize.form.parameters("", (_ref = parameterize.form).section.apply(_ref, [""].concat(__slice.call((function() {
      var _results;
      _results = [];
      for (name in params) {
        param = params[name];
        _results.push(param);
      }
      return _results;
    })()))));
  };

  getModelParameters = safeExport('morpheus.gui.getModelParameters', {}, function(modelName) {
    var k, params, v, _ref;
    if ((modelName != null) && (state.models[modelName] != null)) {
      return wrapParams(state.models[modelName].params);
    }
    params = {};
    _ref = state.models;
    for (k in _ref) {
      v = _ref[k];
      params[k] = wrapParams(v.params);
    }
    return params;
  });

  getModelArguments = safeExport('morpheus.gui.getModelArguments', {}, function(modelName) {
    var args, k, v, _ref;
    if ((modelName != null) && (state.models[modelName] != null)) {
      return state.models[modelName].args;
    }
    args = {};
    _ref = state.models;
    for (k in _ref) {
      v = _ref[k];
      args[k] = v.args;
    }
    return args;
  });

  setModelArguments = safeExport('morpheus.gui.setModelArguments', {}, function(modelName, args) {
    var dimensionType, globalScale, k, model, v, _render, _scaleArgument, _unwrap;
    globalScale = 0.1;
    _unwrap = function(data) {
      switch (data._tag) {
        case 'tolerance':
        case 'range':
          return data[0];
        default:
          return data;
      }
    };
    dimensionType = {
      real: true,
      dimension1: true,
      dimension2: true,
      dimension3: true,
      vector2: true,
      vector3: true,
      point2: true,
      point3: true,
      pitch1: true,
      pitch2: true,
      pitch3: true,
      angle: false,
      polar: false,
      cylindrical: void 0,
      spherical: void 0,
      integer: false,
      natural: false,
      latice1: false,
      latice2: false,
      latice3: false,
      boolean: false,
      option: false
    };
    _scaleArgument = function(arg, param) {
      var a, tag;
      tag = (_unwrap(param))._tag;
      if (!(dimensionType[tag] != null)) {
        throw "Parameter type " + tag + " is not yet supported.";
      }
      if (!dimensionType[(_unwrap(param))._tag]) {
        return arg;
      }
      if (Array.isArray(arg)) {
        return (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = arg.length; _i < _len; _i++) {
            a = arg[_i];
            _results.push(a * globalScale);
          }
          return _results;
        })();
      } else if (typeof arg === 'object') {
        if (!arg.min && arg.max) {
          throw "Could not find min and max keys for toleranced argument.";
        }
        if (Array.isArray(arg.min)) {
          return {
            min: (function() {
              var _i, _len, _ref, _results;
              _ref = arg.min;
              _results = [];
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                a = _ref[_i];
                _results.push(a * globalScale);
              }
              return _results;
            })(),
            max: (function() {
              var _i, _len, _ref, _results;
              _ref = arg.max;
              _results = [];
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                a = _ref[_i];
                _results.push(a * globalScale);
              }
              return _results;
            })()
          };
        } else {
          return {
            min: arg.min * globalScale,
            max: arg.max * globalScale
          };
        }
      }
      return arg * globalScale;
    };
    _render = function(model, args) {
      var arg, id, k, newArgs, param, paramToUniform, uniformID, _ref;
      paramToUniform = {};
      if (model.params != null) {
        _ref = model.params;
        for (uniformID in _ref) {
          param = _ref[uniformID];
          id = _unwrap(param)[0];
          paramToUniform[id] = uniformID;
        }
      }
      newArgs = {};
      for (k in args) {
        arg = args[k];
        newArgs[k] = _scaleArgument(arg, model.params[paramToUniform[k]]);
      }
      return morpheus.renderer.modelArguments(modelName, newArgs, model.params);
    };
    if (!(modelName != null)) {
      for (k in args) {
        v = args[k];
        model = state.models[k];
        if (!(model != null)) {
          throw "No model with the name '" + modelName + "' exists in the scene.";
        }
        _render(model, v);
      }
      return;
    }
    model = state.models[modelName];
    if (!(model != null)) {
      throw "No model with the name '" + modelName + "' exists in the scene.";
    }
    _render(model, args);
  });

  /*
  getModelDefaultArguments = safeExport 'morpheus.gui.getModelParameters', {}, (modelName) ->
    params = state?.models[modelName]?.params
    for name,attr of params
      if not (name in model.args)
        [id,meta,defaultValue] = ["", {}, 0]
        switch attr._tag
          when 'tolerance'
            [id,meta,defaultValue] = attr[0] # unwrap tolerance tag
            if Array.isArray defaultValue.min
              defaultValue = ((defaultValue.min[i] + defaultValue.max[i]) * 0.5 for i in [0...defaultValue.min.length])
            else
              defaultValue = (defaultValue.min + defaultValue.max) * 0.5
          when 'range'
            throw "TODO: Range not yet implemented"
          else
            [id,meta,defaultValue] = attr
        model.args[name] = defaultValue # TODO: handle tolerance value here?
  */


  result = typeof exports !== "undefined" && exports !== null ? exports : {};

  result.create = create;

  result.createControls = createControls;

  result.createEditor = createEditor;

  result.sceneScript = sceneScript;

  result.sceneReset = sceneReset;

  result.getModelParameters = getModelParameters;

  result.getModelArguments = getModelArguments;

  result.setModelArguments = setModelArguments;

  return result;

}).call(this);
